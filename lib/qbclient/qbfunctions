#
### Qbittorent shell client
##
##

# Log in to the server
#
# Usage: qblogin [-k] [-p PASSWORD] URL LOGIN

function qblogin () {
if [ ! -z "$QBurl" ]
    then
     echo Already authorized
     return 1
fi
local curlopt1
local curlopt2
if [ "$1" == "-k" ]
    then
     curlopt1="-k"
     curlopt2=""
     shift
    else
     if [ "$1" == "-c" ]
        then
         curlopt1="--cacert"
         curlopt2="$2"
         shift
         shift
        else
         curlopt1=""
         curlopt2=""
     fi
fi
local login
if [ "$1" == "-l" ]
    then
     login="$2"
     shift
     shift
    else
     login="admin"
fi
local password
if [ "$1" == "-p" ]
    then
     password="$2"
     shift
     shift
    else
     password=""
fi
if [ -z "$1" ]
    then
     echo 'Usage: qblogin [(-k | -c CERTFILE)] [-l USERNAME] [-p PASSWORD] URL'
     return 127
fi
if [ -z "$password" ]
    then
     read -rs -p "Password for $login: " password
     echo
fi
QBarg1=$curlopt1
QBarg2=$curlopt2
password=$(echo "$password" | jq  -rR @uri)
login=$(echo "$login" | jq  -rR @uri)
local exitcode=""
QBcookie=$(curl $curlopt1 $curlopt2 -i --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null |
while read line1 line2 line3; do [ -z $exitcode ] && { exitcode=$line2; printf "$line2;"; }; [ $line1 == "set-cookie:" ] && printf $line2; done)
exitcode=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line1 ) )
QBcookie=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line2 ) )
#QBcookie=$(curl $QBarg1 $QBarg2 -c - --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null | cut -sf7)
if [ -z "$QBcookie" ]
    then
     if [ "$exitcode" == 200 ]
        then
         echo "Fail. Invalid username/password"
         return 126
        else
         if [ "$exitcode" == 403 ]
            then
             echo "Fail. Your IP is banned"
             return 126
            else
             echo "Fail. Check URL and/or SSL certificate"
             return 1
         fi
     fi
fi
QBurl=$1
QBarg1=$curlopt1
QBarg2=$curlopt2
#QBcookie="SID=$QBcookie"
echo Success
}


# Log out
# Usage: qblogout

function qblogout ()
{
if [ -z "$QBurl" ]
    then
     echo "Not logged in"
     return 1
fi
local exitcode=$(curl $QBarg1 $QBarg2 -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/auth/logout" 2>/dev/null)
if [ "$exitcode" == 200 ]
    then
     unset QBurl
     unset QBcookie
     unset QBhash
     unset QBarg1
     unset QBarg2
     echo Logged out
     return 0
    else
     echo 'Logout with the following cookie did not succeed:'
     echo "$QBcookie"
     return 1
    fi
}

# Add url
#
# Usage: qbaddurl "URL" (use quotes!)

function qbaddurl ()
{
curl $QBarg1 $QBarg2 -F "urls=$1" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
}

# Add torrent file
#
# Usage: qbaddfile FILENAME

function qbaddfile ()
{
local tmptorrent=$(mktemp)
cp "$1" "$tmptorrent"
curl $QBarg1 $QBarg2 -F 'torrents=@'"$tmptorrent" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
rm "$tmptorrent"
}

# Add torrent file in the paused state
#
# Usage: qbaddaused FILENAME

function qbaddpaused ()
{
local tmptorrent=$(mktemp)
cp "$1" "$tmptorrent"
curl $QBarg1 $QBarg2 -F 'torrents=@'"$tmptorrent" -F "paused=true" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
rm "$tmptorrent"
}

# Get the value of specified prefernce property, or print all preferences
#
# Usage: qbprefget [PREF_PROPERTY]
 
function qbprefget ()
{
if [ "x$1" == "x" ]
then
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq -r ".$1"
fi
}

# Set a new value of the preference property
#
# Usage: qbprefset [-s] [-n] PREF_PROPERTY NEW_VALUE

function qbprefset ()
{
local silent="false"
local nocheck="false"
local strval=""
if  [ "$1" == "-s" ]
    then
     silent="true"
     shift
fi
if  [ "$1" == "-n" ]
    then
     silent="true"
     nocheck="true"
     shift
fi
strval=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq ".$1")
if [ "$strval" = "null" ]
    then
     if [ "$silent" == "false" ]
        then
         echo No such option
     fi
    else
     if [ "$silent" == "false" ]
        then
         echo Old value: "$strval"
     fi
     strval=${strval:0:1}
     if [ "$strval" == '"' ]
        then
         strval='json='$(echo {} | jq -c --arg k "$1" --arg v "$2" '[ { "key" : $k, "value": $v } ] | from_entries ')
        else
         strval='json='$(echo {} | jq -c --arg k "$1" '[ { "key" : $k, "value":'"$2"' } ] | from_entries ')
     fi
     curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/app/setPreferences" --data-urlencode "$strval"
     if [ "$nocheck" == "false" ]
        then
         strval=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq  ".$1")
         echo  New value: "$strval"
     fi
fi
}

# Change password
#
# Usage: qbpasswd

function qbpasswd ()
{
local newpasswd
local newpasswd1
read -rs -p "New password: " newpasswd
echo
read -rs -p "Retype new password: " newpasswd1
echo
if [ "$newpasswd" == "$newpasswd1" ] 
    then
     newpasswd='json='$(echo {} | jq --arg pass "$newpasswd" '{ "web_ui_password": $pass }')
     curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/app/setPreferences" --data-urlencode "$newpasswd"
    else
     echo Different passwords
fi
}

# List of torrents with a short info. The torrents are sorted by the addition time. The new torrents always in the end
#
# Usage: qbinfo

function qbinfo ()
{
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq 'to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+(.value.size /1048576|trunc|tostring)+"Mb, state:"+.value.state'
}

# Select the torrent with the specified index from qbinfo ()
#
# Usage: qbselect [-s] [INDEX]
# Option -s: silent mode

function qbselect ()
{
local silent
if  [ "$1" == "-s" ]
then
silent="yes"
shift
else
silent=""
fi
if [ "x$1" == "x" ] && [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" != "x" ]
then
QBhash=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
fi
if [ "x$silent" == "x" ]
then
echo Torrent with hash="$QBhash" is selected
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq '.[] | .name+", "+(.progress*100|trunc|tostring)+"% of "+(.size /1048576|trunc|tostring)+"Mb, state:"+.state'
fi
fi
}

# Delete the selected torrent. The correct index from qbinfo () must be specifies.
#
# Usage: qbdel INDEX

function qbdel ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
local checkhash=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
if [ "$QBhash" == "$checkhash" ]
then
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/delete?hashes=$QBhash&deleteFiles=true" 
unset QBhash
else
echo The selected hash $QBhash differ for the hash of $1
fi
fi
}

# Get the specified information of the selected torrent, or print it completely
#
# Usage: qbtorinfo [INFO_PROPERTY]

function qbtorinfo ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" = "x" ]
then
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq '.[]'
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -r '.[].'"$1"
fi
fi
}

# Get the specified property of the selected torrent, or print all it's properties 
#
# Usage: qbpropinfo [GEN_PROPERTY]

function qbtorprop ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" = "x" ]
then
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq -r ".$1"
fi
fi
}

# Trackers info of the selected torrent
#
# Usage: qbtrackers

function qbtrackers ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/trackers?hash=$QBhash" | jq '.[]'
fi
}

# Pause, resume, recheck and reannounce of the selected torrent
#
# Usage: qbcommand COMMAND.
# COMMAND = pause, resume, recheck, reannounce

function qbcommand ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" = "x" ]
then
echo Usage: qbcommand COMMAND 
echo COMMAND = pause, resume, recheck, reannounce
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/$1?hashes=$QBhash"
fi
fi
}

# Toggle Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# Usage: qbmedia ARG1 [ARG2]

function qbmedia ()
{
if [ $# -lt 1 ]
    then
     echo 'Usage: qbmedia ARG1 [ARG2]'
    else
     if [ -z "$QBhash" ]
        then
         echo No torrent is selected
        else
         local se="$1"
         local fl="$1"
         if [ $# -gt 1 ]
            then fl="$2"
         fi
         local oldval=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -rc '.[] | [ .seq_dl, .f_l_piece_prio ]')
         local oldse=$(echo "$oldval" | jq -r '.[0]')
         local oldfl=$(echo "$oldval" | jq -r '.[1]')
         [ "$se" == "$oldse" ] || curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleSequentialDownload?hashes=$QBhash"
         [ "$fl" == "$oldfl" ] || curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleFirstLastPiecePrio?hashes=$QBhash"
     fi
fi
}

# Set new location of downloaded files of the selected torrent
#
# Usage: qbsetlocation NEW_LOCATION

function qbsetlocation ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" = "x" ]
then
echo Usage: qbsetlocation NEW_LOCATION
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/setLocation?hashes=$QBhash&location=$1"
fi
fi
}

# Peers info of the selected torrent
#
# Usage: qbpeers

function qbpeers ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/sync/torrentPeers?hash=$QBhash"| jq '[.peers | .[]] | sort_by(.progress) |.[] | (.progress*100 | trunc | tostring)+"% "+.ip+" "+.country_code+" "+(.dl_speed /1024 |trunc|tostring)+"Kb/s "+.client+"("+.connection+")"'
fi
}



#Scaled pieces state string
#
#Usage: qbpieceview [-n [NUMBER_OF_BLOCKS]] [(-o FILE_INDEX | -i FILE_INDEX1 [FILE_INDEX2])]
function qbpieceview ()
{
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
local aone="$COLUMNS"
if [ "$1" == "-n" ]
    then
     if [ ${2:0:1} == "-" ]
        then
         aone=""
        else
         aone="$2"
         shift
     fi
     shift
fi
if [ "$1" == "-o" ]
    then
     local pi=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
     jq --arg i "$2" 'sort_by(.name)|.[($i|tonumber)].piece_range')
     if [ -z "$aone" ]
        then
         curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" '.[$pi|.[0]:($pi|.[1])+1]|[.[]|if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
        else
         curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" --arg aone "$aone" '.[$pi|.[0]:($pi|.[1])+1]|
         length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
         [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
         reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
         if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
     fi
    else
     if [ "$1" == "-i" ]
        then
         local arg3="$3"
         if [ -z $arg3 ]
            then
             arg3="$2"
         fi
         pi=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
         jq -c --arg i "$2" --arg j "$arg3" 'sort_by(.name) as $inp|reduce range($i|tonumber;($j|tonumber)+1) as $n ([];.+[($inp|.[$n]).piece_range|range(.[0];.[1]+1)]|unique)')
         if [ -z "$aone" ]
            then
             curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" '. as $inp|length as $len| [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" --arg aone "$aone" '. as $inp|length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|
             [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end]|
             [.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
        fi
        else
         if [ -z "$aone" ]
            then
             curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r '[.[]|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r --arg aone "$aone" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
         fi
     fi
fi
     #jq --argjson pi "$pi" '. as $inp|[range($pi|.[0];($pi|.[1])+1)]|.[]| . as $ind | $inp|.[$ind]'
     #|.[]|. as $ind|($inp|.[$ind])]'

     #jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | .['"$1"'].key'
     #curl $QBarg1 $QBarg2 -s  --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq '.['"$index"']
#fi
#curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
#jq -r --arg aone "$1" ""'[length as $len|($aone|tonumber) as $size|to_entries |[.[]|{ "a":(.key*$size/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
}



# List the files of the selected torrent with a short info
#
# Usage: qbcontent [FILE_INDEX_1] [FILE_INDEX_2]

function qbcontent ()
{
if [ -z "$QBhash" ]
    then
     echo "No torrent is selected"
     return 1
fi
local arg2
if [ -z "$1" ]
    then
     curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name) |  to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
    else
     if [ -z $2 ]
        then arg2="$1"
        else arg2="$2"
     fi
     curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name)|to_entries|[.['"$1"']]+.['"$1"'+1:'"$arg2"'+1]|.[]|(.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
fi



return 0
}

# Get the info of the specified file of the selected torrent
#
# Usage: qbcfileinfo FILE_INDEX
# FILE_INDEX corresponds to the output of qbcontent ()

function qbfileinfo ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" == "x" ]
then
echo Usage: qbcfileinfo FILE_INDEX
else
local index=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | .['"$1"'].key')
curl $QBarg1 $QBarg2 -s  --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq '.['"$index"']'
fi
fi
}

# Set priority of the specified file of the selected torrent, or set the priority for all it's files
#
# Usage: qbfileprio NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
# FILE_INDEX corresponds to the output of qbcontent ()

function qbfileprio ()
{
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo Usage: qbfileprio NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
     return 127
fi
local index=""
local arg3
if [ -z "$2" ]
    then
     index=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -r '["0"]+[range(1;length)|tostring|"|"+.]|add' 2>/dev/null)
    else
     if [ -z $3 ]
        then arg3="$2"
        else arg3="$3"
     fi
     index=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | [(.['"$2"'].key|tostring)]+ [.['"$2"'+1:'"$arg3"'+1] | "|"+(.[].key|tostring)]|add' 2>/dev/null)
fi
if [ -z "$index" ]
    then
     echo "Fail"
     return 1
fi
local exitcode=$(curl $QBarg1 $QBarg2 -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/filePrio?hash=$QBhash&id=$index&priority=$1" 2>/dev/null)
if [ "$exitcode" == "200" ]
    then return 0
    else
     #TODO: add the exitcodes 400, 404,409
     echo "Fail"
     return 1
fi
}

##### Experimental functions not declared in Qbittorrent WebAPI

# Download torrent file of selected torrent to $1
# The variable $local_path must be set up in the code below
#
# Usage: qb_get_torrent_file [FILE_NAME]

function qb_get_torrent_file ()
{
# The $localpath is the share folder of the server. Usually it is ~/.local/share/qBittorrent
# It must contain simlink "BT_backup"->"public"
# Rename "BT_backup" to "public" and make such a simlink on the server side
local local_path="/home/user/.local/share/qBittorrent"
#
if [ "x$QBhash" == "x" ]
    then
     echo No torrent is selected
    else
     local save_file
     if [ "x$1" == "x" ]
        then
         save_path="$(qbtorinfo name).torrent"
        else
         save_path="$1"
     fi
     if [ -f "$save_path" ]
        then
         echo File "$save_path" already exists
        else
         local alternative_webui_enabled=$(qbprefget alternative_webui_enabled)
         local alternative_webui_path=$(qbprefget alternative_webui_path)
         qbprefset alternative_webui_path \""$local_path"\"
         qbprefset alternative_webui_enabled true
         curl $QBarg1 $QBarg2 -s --cookie $QBcookie "$QBurl/$QBhash.torrent" --output "$save_path"
         qbprefset alternative_webui_enabled "$alternative_webui_enabled"
         qbprefset alternative_webui_path \""$alternative_webui_path"\"
         if [ -f "$save_path" ]
            then
             echo  File "$save_path" sucessfully downloaded
            else
             echo An error is occurred $save_file
         fi
      fi
fi
}

# Add url into the torrent client ensuring that the actual download will be paused
#
# Usage: qb_add_url_paused "URL" (use quotes!)

function qb_add_url_paused ()
{
local response=$(curl $QBarg1 $QBarg2 -F "urls=$1" -F "dlLimit=50000" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add" 2>/dev/null)
if [ $response == "Ok." ]
then
QBhash=$(curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on&reverse=true" | jq -r '.[0].hash')
local state=metaDL
echo; echo Downloading metadata...
while [ $state == "metaDL" ]
    do
     state=$(qbtorinfo state)
    done
qb_get_torrent_file $QBhash.torrent > /dev/null
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/delete?hashes=$QBhash&deleteFiles=true"
curl $QBarg1 $QBarg2 -F 'torrents=@'"$QBhash.torrent" -F "paused=true" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
rm $QBhash.torrent
echo
else
echo An error is occurred
fi
}

#generic curl call
function qbcurl ()
{
curl $QBarg1 $QBarg2 -s --cookie "$QBcookie"  "${QBurl}/api/v2/$1"
echo
}


#jq '[length as $len|to_entries |[.[]|{ "a":(.key*100/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 or (.==2 and $n!=2) then $n else if $n==1 then 1 else . end end)|tostring]|add'

 #qbcurl "torrents/pieceStates?hash=$QBhash" | jq -r --arg aone "$arg" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
 #[to_entries |[.[]|{"a":(.key*$size*$mult/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
 #reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
