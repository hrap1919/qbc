#
### Qbittorent shell client
##
##
function exit ()
{
{ 2>&3 curl "${QBarg[@]}" -s --cookie $QBcookie "${QBurl}/api/v2/auth/logout" &>/dev/null & } 3>&2 2>/dev/null
disown &>/dev/null
local exitcode=0
[ -z "$1" ] || exitcode="$1"
builtin exit "$exitcode"
}

function __META_qblogin ()
{
local exitcode=""
QBcookie=$(curl "${QBarg[@]}" -s -i --header "Referer: $QBurl" --data "username=$QBlogin&password=$QBpassword" "$QBurl/api/v2/auth/login" 2>/dev/null |
while read line1 line2 line3; do [ -z "$exitcode" ] && { exitcode="$line2"; printf "$line2;"; }; [ "$line1" == "set-cookie:" ] && printf "$line2"; done)
exitcode=$(echo "$QBcookie" | ( IFS=";"; read line1 line2; echo $line1 ) )
QBcookie=$(echo "$QBcookie" | ( IFS=";"; read line1 line2; echo $line2 ) )
#QBcookie=$(curl "${QBarg[@]}" -c - --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null | cut -sf7)
if [ -z "$QBcookie" ]
    then
     if [ "$exitcode" == 200 ]
        then
         >&2 echo "Fail. Invalid username/password"
         return 126
        else
         if [ "$exitcode" == 403 ]
            then
             >&2 echo "Fail. Your IP is banned"
             return 126
            else
             >&2 echo "Fail. Check URL and/or SSL certificate"
             return 1
         fi
     fi
fi
return 0
}


## qbcurl: Make a custom cURL WebUI request to the qBittorrent server
## qbcurl: The use of "api/v2" is assumed
## Usage: qbcurl URL_COMMAND [CURL_OPT_1] [CURL_OPT_2] ...
## qbcurl: Encapsulate URL_COMMAND symbols in quotes if necessary
## qbcurl: The "$QBhash" variable can be used in URL_COMMAND to pass the hash of the selected torrent
## qbcurl: Example: qbcurl "torrents/files?hash=$QBhash" -s | jq

#alias qbcurl="__META_qbcall qbcurl"
function __META_qbcurl ()
{
if [ -z "$1" ]
    then
     qbhelp -u qbcurl
     return 127
fi
local command="$1"
shift
curl "${QBarg[@]}" --cookie "$QBcookie" "$@" "${QBurl}/api/v2/$command"
return $?
}

function __META_qbrequest ()
{
local opt="raw"
if [ "$1" == "-e" ]
    then
     opt="code"
     shift
fi
local method="$1"
shift
local resp
if [ "$opt" == "raw" ]
    then
     resp=$(__META_qbcurl "$method" -s "$@")
     if [ "$resp" == "Forbidden" ]
        then
         __META_qblogin
         resp=$?
         [ "$resp" == "0" ] || builtin exit "$resp"
         resp=$(__META_qbcurl "$method" -s "$@")
     fi
    else
     resp=$(__META_qbcurl "$method" -s -o /dev/null -w "%{http_code}" "$@")
     if [ "$resp" == "403" ]
        then
         __META_qblogin
         resp=$?
         [ "$resp" == "0" ] || builtin exit "$resp"
         resp=$(__META_qbcurl "$method" -s -o /dev/null -w "%{http_code}" "$@")
     fi
fi
echo "$resp"
return 0
}


function __META_qbcall ()
{
if [ "$2" == "-h" ]
    then
     __META_qbhelp -u "$1"
    else
     if [ "$2" == "--help" ]
        then
         __META_qbhelp "$1"
        else
         local func="$1"
         shift
         #if [ "$func" != "qbhelp" ] && [ "$(($(date +%s)-$QBchtime))" -ge "10" ]
            #then
             #resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/app/version" 2>/dev/null)
             #if [ "$resp" != "200" ]
                #then
                 #__META_qblogin
                 #exitcode=$?
                 #[ "$exitcode" == "0" ] || builtin exit "$exitcode"
             #fi
             #QBchtime=$(date +%s)
         #fi
         "__META_$func" "$@"
     fi
fi
}

# qbhelp: qbclient usage help
# Usage: qbhelp [(list | [-u] FUNCTION)]
# Usage:qbhelp Usage: FUNCTION (-h|--help)
# qbhelp: Options:
# qbhelp: list - list of available FUNCTIONs
# qbhelp: -u FUNCTION - the usage of FUNCTION
# qbhelp: FUNCTION - the help for FUNCTION

alias qbhelp="__META_qbcall qbhelp"
function __META_qbhelp ()
{
if [ "$1" == "list" ]
    then
     while read line1 line2 line3 line4
        do
         [ "$line1" == "#" ] && [ "$line2" == "Usage:" ] && echo "$line3"
        done < "$BASH_ENV"
    else
     local usage=""
     if [ "$1" == "-u" ]
        then
         usage="yes"
         shift
     fi
     local funct="$1"
     [ -z "$1" ] && funct="qbhelp"
     [ "${funct:0:2}" == "qb" ] || funct="qb$funct"
     while read line1 line2 line3 line4
        do
         if [ "$line1" == "#" ] && [ "$line2" == "Usage:" ] && [ "$line3" == "${funct}" ]
            then
             echo "Usage: $line3 $line4"
             echo
            else
             if  {
                  [ "$line1" == "#" ] && [ "$line2" == "Usage:${funct}" ]
                 } ||
                 {
                  [ -z "$usage" ] && [ "$line1" == "#" ] && [ "$line2" == "${funct}:" ]
                 }
                then
                 echo "$line3 $line4"
                 echo
             fi
         fi
        done < "$BASH_ENV"
fi
}


# qbversion: Print the versions of used software
# Usage: qbversion [(app|api|build [qt|libtorrent|boost|openssl|bitness])]
alias qbversion="__META_qbcall qbversion"
function __META_qbversion ()
{
if [ -z "$1" ]
    then
     echo "Early pre-alpha"
     return 0
fi
resp="null"
if [ "$1" == "app" ]
    then
     resp=$(__META_qbrequest "app/version" 2>/dev/null)
    else
     if [ "$1" == "api" ]
      then
      resp=$(__META_qbrequest "app/webapiVersion" 2>/dev/null)
     fi
fi
if [ "$1" == "build" ]
    then
     resp=$(__META_qbrequest "app/buildInfo" 2>/dev/null)
     if [ -z "$resp" ]
        then
         >&2 echo 'An error is occured'
         return 1
     fi
     if [ -z $2 ]
        then
         echo $resp | jq 2>/dev/null
         return 0
        else
         resp=$(echo $resp| jq -r ".$2" 2>/dev/null)
     fi
fi
if [ -z "$resp" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
if [ "$resp" == "null" ]
    then
     >&2 qbhelp -u qbversion
     return 127
    else
     echo $resp
     return 0
fi
}

# qbpref: Show the value of specified preference property, or print all preferences
# Usage: qbpref [(-r PREF_PROPERTY | PREF_PROPERTY_1 [PREF_PROPERTY_2 ...])]
# qbpref: With the "-r" option the function returns the raw value of a property

alias qbpref="__META_qbcall qbpref"
function __META_qbpref ()
{
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         >&2 qbhelp -u qbpref
         return 127
     fi
     __META_qbrequest "app/preferences" 2>/dev/null | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     __META_qbrequest "app/preferences" 2>/dev/null | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     __META_qbrequest "app/preferences" 2>/dev/null | jq "$jj"
fi
return 0
}


# qbprefedit: Send new values of specified preference properties
# Usage: qbprefedit [-s] [-n] PREF_PROPERTY_1 NEW_VALUE_1 [PREF_PROPERTY_2 NEW_VALUE_2 ...]
# qbprefedit: The option -n prevents an additional check the values from the server after the request. The option "-s" forces "-n" and also prevents any output or user confirmations except (may be) error messages
# qbprefedit: To change the WebUI password by a secure way (from stdin) just omit the NEW_VALUE_1 argument in "qbprefedit web_ui_password". A change of web_ui_password property together with another options is not supported.

alias qbprefedit="__META_qbcall qbprefedit"
function __META_qbprefedit ()
{
local silent="false"
local nocheck="false"
local strval=""
if  [ "$1" == "-s" ]
    then
     silent="true"
     nocheck="true"
     shift
fi
if  [ "$1" == "-n" ]
    then
     nocheck="true"
     shift
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbprefedit
     return 127
fi
if [ "$1" == "web_ui_password" ]
then
local newpasswd
local newpasswd1
if [ -z "$2" ]
    then
     read -rs -p "New password: " newpasswd
     echo
     read -rs -p "Retype new password: " newpasswd1
     echo
    else
     newpasswd="$2"
     newpasswd1="$2"
fi
if [ "$newpasswd" == "$newpasswd1" ]
    then
     newpasswd='json='$(echo {} | jq --arg pass "$newpasswd" '{ "web_ui_password": $pass }')
     local resp=$(__META_qbrequest -e "app/setPreferences" --data-urlencode "$newpasswd" 2>/dev/null)
     if [ "$resp" != "200" ]
        then
         [ "$silent" == "true" ] || >&2 echo 'An error is occured'
         return 1
        else
         [ "$silent" == "true" ] || >&2 echo 'The password was sent'
         return 0
     fi
    else
     >&2 echo 'Different passwords'
     return 1
fi
fi
local pref=$(__META_qbrequest "app/preferences" 2>/dev/null)
if [ -z "$pref" ]
    then
     >&2 echo 'An error is occured'
    return 1
fi
local j='{}'
while [ ! -z "$1" ]
    do
     if [ "$1" == "web_ui_password" ]
        then
         >&2 echo 'Can not change "web_ui_password" together with other preferences'
         return 1
     fi
     local t2=$(echo $pref| jq ".$1")
     if [ ${t2:0:1} == '"' ]
        then
         j=$(echo "$j" | jq -c --arg k "$1" --arg v "$2" '.+([ { "key" : $k, "value": $v } ] | from_entries)' 2>/dev/null)
        else
         j=$(echo "$j" | jq -c --arg k "$1" '.+([ { "key" : $k, "value":'"$2"' } ] | from_entries)' 2>/dev/null)
     fi
     if [ -z "$j" ]
        then
         [ "$silent" == "true" ] || >&2 echo 'An error is occured'
         return 1
     fi
     shift
     shift
    done
local resp=''
local jj=''
if [ "$silent" == "false" ]
    then
     jj=$(echo $j | jq -r 'to_entries|"{"+([.[]|"\""+.key+"\":"+"."+.key+","]|add|.[0:length-1])+"}"' 2>/dev/null)
     echo 'Old preferences:'
     echo $pref| jq "$jj" 2>/dev/null
     echo 'New preferences:'
     echo $j | jq 2>/dev/null
     read -r -p 'Type "yes" to send the new preferences to the server: ' resp
     if [ "$resp" != "yes" ]
        then
         >&2 echo 'Cancelled'
         return 1
     fi
fi
resp=$(__META_qbrequest -e "app/setPreferences" --data-urlencode "json=$j" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
if [ "$nocheck" == "false" ]
    then
     local pref=$(__META_qbrequest "app/preferences" -s)
     echo 'Just checked preferences:'
     echo $pref| jq $jj 2>/dev/null
    else
     if [ "$silent" == "false" ]
        then
         echo 'The preferences were sent'
     fi
fi
}

# qbaltspeed: Get the state of the alternative speed mode
# Usage: qbaltspeed

alias qbaltspeed="__META_qbcall qbaltspeed"
function __META_qbaltspeed ()
{
local resp=$(__META_qbrequest "transfer/speedLimitsMode" 2>/dev/null)
if [ "$resp" == "0" ]
    then
     echo false
     return 0
fi
if [ "$resp" == "1" ]
    then
     echo true
     return 0
fi
>&2 echo 'An error is occured'
return 1
}

# qbaltspeededit: Set the state of the alternative speed mode
# Usage: qbaltspeededit (true|false)
# qbaltspeededit: any nonepty argument except "true" and "false" causes a togglement of the mode

alias qbaltspeededit="__META_qbcall qbaltspeededit"
function __META_qbaltspeededit ()
{
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbaltspeededit
     return 127
fi
local resp=$(__META_qbaltspeed)
[ -z "$resp" ] && return 1
if [ "$resp" != "$1" ]
    then
     resp=$(__META_qbrequest -e "transfer/toggleSpeedLimitsMode" 2>/dev/null)
     [ "$resp" == "200" ] && return 0
     >&2 echo 'An error is occured'
     return 1
fi
return 0
}



# qbnetwork:  Show the general network status of the server
# Usage: qbnetwork
alias qbnetwork="__META_qbcall qbnetwork"
function __META_qbnetwork ()
{
__META_qbrequest "transfer/info" 2>/dev/null |jq
}




# qblist: List of torrents with a short info. The torrents are sorted by the addition time. The new torrents always in the end
# Usage: qblist

alias qblist="__META_qbcall qblist"
function __META_qblist ()
{
__META_qbrequest "torrents/info?sort=added_on" 2>/dev/null |jq 'to_entries | .[] |
(.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+(.value.size /1048576|trunc|tostring)+"Mb, state:"+.value.state'
}


# qblistadd: Add a torrent by a URL (use quotes), or by a torrent FILE.
# Usage: qblistadd ( -u 'URL'| -f FILE)  [ARG_1=VALUE_1] [ARG_2=VALUE_2] ...
# qblistadd: If FILE='-' then the content of a torrent file will be read from stdin
# qblistadd: The available ARGs are listed in WebUI API https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#add-new-torrent

alias qblistadd="__META_qbcall qblistadd"
function __META_qblistadd ()
{
local datarray=("${QBarg[@]}")
datarray+=("-s" "-o" "/dev/null" "-w" "%{http_code}" "--cookie" "$QBcookie")
local farg=""
if [ "$1" == "-u" ]
    then
     local uarg=""
     if [ "$2" == "-" ]
        then
         echo 'Paste the url and press Enter:'
         read -r uarg
        else
         uarg="$2"
     fi
     if [ -z "$uarg" ]
        then
         >&2 echo "Empty url"
         return 127
     fi
     datarray+=("-F" "urls=$uarg")
     farg="/dev/null"
    else
     if [ "$1" == "-f" ]
        then
         if [ -z "$2" ]
            then
             >&2 echo "Empty filename"
             return 127
         fi
         datarray+=("-F" "torrents=@-")
         farg="$2"
        else
         >&2 qbhelp -u qblistadd
         return 127
     fi
fi
shift
shift
while [ ! -z "$1" ]
    do
     datarray+=("-F" "$1")
     shift
    done
local oldinfo=$(__META_qbrequest 'torrents/info?sort=added_on' 2>/dev/null)
local resp
if [ "$farg" == '-' ]
    then
     resp=$(curl "${datarray[@]}" "${QBurl}/api/v2/torrents/add" 2>/dev/null)
    else
     resp=$(curl "${datarray[@]}" "${QBurl}/api/v2/torrents/add" 2>/dev/null <"$farg")
fi
if [ "$resp" != "200" ]
    then
      >&2 echo 'An error is occured.'
     return 1
fi
local newinfo=$(__META_qbrequest 'torrents/info?sort=added_on' 2>/dev/null)
local diff=$(jq -rn --argjson j "$oldinfo" --argjson jj "$newinfo" '([$jj|.[]|.hash])-([$j|.[]|.hash])|if (.|length)==1 then (.[0]) else . end')
if [ "$diff" == '[]' ]
    then
      >&2 echo 'Warning: No new torrent is added'
     return 0
fi
if [ "${diff:0:1}" == '[' ]
    then
      >&2 echo 'Warning: More than one torrents were added recently. Please check them manually'
     return 0
fi
QBhash="$diff"
echo "Torrent with hash="$QBhash" is added"
jq -n --arg hash "$QBhash" --argjson jj "$newinfo" '$jj|.[]|select(.hash==$hash)|
.name+", "+(.progress*100|trunc|tostring)+"% of "+(.size /1048576|trunc|tostring)+"Mb, state:"+.state'
}


# qblistremove: Remove the selected torrent.
# Usage: qblistremove [-d] INDEX
# qblistremove: The correct INDEX from qblist must be specifies. Option "-d" removes also the downloaded data Delete the selected torrent.

alias qblistremove="__META_qbcall qblistremove"
function __META_qblistremove ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
local deldata="false"
if [ "$1" == "-d" ]
    then
     deldata="true"
     shift
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qblistdelete
     return 127
fi
local resp=$(__META_qbrequest "torrents/info?sort=added_on" 2>/dev/null | jq -r ".[$1].hash" 2>/dev/null)
if [ "$QBhash" != "$resp" ]
     then
      >&2 echo "The selected hash $QBhash differ for the hash of $1"
      return 1
fi
local resp=$(__META_qbrequest -e "torrents/delete?hashes=$resp&deleteFiles=$deldata" 2>/dev/null)
if [ "$resp" == "200" ]
    then
     unset QBhash
     return 0
fi
echo "An error is occured"
return 1
}

## qbtlistselect: Select the torrent with the specified index from qblist.
## Usage: qblistselect [-s] [INDEX]
## Usage:qblistselect alias qblistselect=qbselect
## qbtorselect: Option -s: silent mode

#alias qblistselect=qbselect


# qbselect: Select the torrent with the specified index from qblist
# Usage: qbselect [-s] [INDEX]
# Usage:qbselect alias qbtorselect=qbselect
## Usage:qbselect alias qblistselect=qbselect
# qbselect: Option -s: silent mode

alias qbselect="__META_qbcall qbselect"
function __META_qbselect ()
{
local silent
if  [ "$1" == "-s" ]
    then
     silent="yes"
     shift
    else
     silent=""
fi
if [ -z "$1" ] && [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
resp=""
if [ ! -z "$1" ]
    then
     resp=$(__META_qbrequest 'torrents/info?sort=added_on' 2>/dev/null)
     QBhash=$(echo "$resp" | jq -r ".[$1].hash")
fi
echo "Torrent with hash="$QBhash" is selected"
local filter='.name+", "+(.progress*100|trunc|tostring)+"% of "+(.size /1048576|trunc|tostring)+"Mb, state:"+.state'
if [  -z "$silent" ]
    then
     if [ -z "$resp" ]
        then
         __META_qbrequest "torrents/info?hashes=$QBhash" 2>/dev/null| jq '.[] |'"$filter"
        else
         echo "$resp" | jq --arg qbhash "$QBhash" '.[]|select(.hash==$qbhash)'"$filter"
     fi
fi
}

# qbtorselect: Select the torrent with the specified index from qblist.
# Usage: qbtorselect [-s] [INDEX]
# Usage:qbtorselect alias qbtorselect=qbselect
# qbtorselect: Option -s: silent mode

alias qbtorselect=qbselect


# qbtordo: Pause, resume, recheck and reannounce of the selected torrent
# Usage: qbtordo (pause | resume | recheck | reannounce)
alias qbtordo="__META_qbcall qbtordo"
function __META_qbtordo ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtordo
     return 127
fi
local resp=$(__META_qbrequest -e "torrents/$1?hashes=$QBhash" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
}


# qbtorinfo: Get the specified information of the selected torrent, or print it completely
# Usage: qbtorinfo [(-r INFO_PROPERTY | INFO_PROPERTY_1 [INFO_PROPERTY_2 ...])]

alias qbtorinfo="__META_qbcall qbtorinfo"
function __META_qbtorinfo ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         >&2 qbhelp -u qbtorinfo
         return 127
     fi
     __META_qbrequest "torrents/info?hashes=$QBhash" 2>/dev/null | jq -r ".[]|.$2"
     return 0
fi
if [ -z "$1" ]
    then
     __META_qbrequest "torrents/info?hashes=$QBhash" 2>/dev/null | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     __META_qbrequest "torrents/info?hashes=$QBhash" 2>/dev/null | jq ".[]|$jj"
fi
return 0
}


# qbtorinfodownloadlimit: Show the download limit of the selected torrent in Kb/s
# Usage: qbtorinfodownloadlimit

alias qbtorinfodownloadlimit="__META_qbcall qbtorinfodownloadlimit"
function __META_qbtorinfodownloadlimit ()
{
qbtorinfo dl_limit | jq -r '.dl_limit|if .>0 then (./1024|trunc) else . end'
return $?
}

# qbtorinfodownloadlimitedit: Set a new save location of the selected torrent
# Usage: qbtorinfodownloadlimit NEW_LIMIT
alias qbtorinfodownloadlimitedit="__META_qbcall qbtorinfodownloadlimitedit"
function __META_qbtorinfodownloadlimitedit ()
{
if [ -z "$QBhash"  ]
then
>&2 echo No torrent is selected
return 1
else
if [ -z "$1" ]
then
>&2 qbhelp -u qbtorinfodownloadlimitedit
return 1
else
local arg=$(jq -rn "$1|if .<0 then -1 else .*1024 end")
resp=$(__META_qbrequest -e "torrents/setDownloadLimit?hashes=$QBhash&limit=$arg" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
fi
fi
}

# qbtorinfouploadlimit: Show the download limit of the selected torrent in Kb/s
# Usage: qbtorinfouploadlimit

alias qbtorinfouploadlimit="__META_qbcall qbtorinfodownloadlimit"
function __META_qbtorinfouploadlimit ()
{
qbtorinfo up_limit | jq -r '.dl_limit|if .>0 then (./1024|trunc) else . end'
return $?
}

# qbtorinfouplimitedit: Set a new save location of the selected torrent
# Usage: qbtorinfouploadlimit NEW_LIMIT
alias qbtorinfouploadlimitedit="__META_qbcall qbtorinfodownloadlimitedit"
function __META_qbtorinfouploadlimitedit ()
{
if [ -z "$QBhash"  ]
then
>&2 echo No torrent is selected
return 1
else
if [ -z "$1" ]
then
>&2 qbhelp -u qbtorinfouploadlimitedit
return 1
else
local arg=$(jq -rn "$1|if .<0 then -1 else .*1024 end")
resp=$(__META_qbrequest -e "torrents/setUploadLimit?hashes=$QBhash&limit=$arg" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
fi
fi
}

# qbtorinfolocation: Show the save location of the selected torrent
# Usage: qbtorinfolocation

alias qbtorinfolocation="__META_qbcall qbtorinfolocation"
function __META_qbtorinfolocation ()
{
qbtorinfo -r save_path
return $?
}

# qbtorinfolocationedit: Set a new save location of the selected torrent
# Usage: qbtorinfolocationedit NEW_LOCATION
alias qbtorinfolocationedit="__META_qbcall qbtorinfolocationedit"
function __META_qbtorinfolocationedit ()
{
if [ -z "$QBhash"  ]
then
>&2 echo No torrent is selected
return 1
else
if [ -z "$1" ]
then
>&2 qbhelp -u qbtorinfolocationedit
return 1
else
local arg=$(echo $1|jq -rR '@uri')
resp=$(__META_qbrequest -e "torrents/setLocation?hashes=$QBhash&location=$arg" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
fi
fi
}


# qbtorinfosequential: Show  Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# Usage: qbtorinfosequential
alias qbtorinfosequential="__META_qbcall qbtorinfosequential"
function __META_qbtorinfosequential ()
{
qbtorinfo seq_dl f_l_piece_prio
return $?
}


# qbtorinfosequentialedit: Control of Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# Usage: qbtorinfosequentialedit ARG1 [ARG2]
# qbtorinfomedia: Set Sequential_Download property of the selected torrent to ARG1. Set First_Last_Piece_Priority property either to ARG2, or to ARG1 (if ARG2 is absent). Each of ARG1 and ARG2 must be equal to either "true" or "false"

alias qbtorinfosequentialedit="__META_qbcall qbtorinfosequentialedit"
function __META_qbtorinfosequentialedit ()
{
if [ $# -lt 1 ]
    then
     >&2 qbhelp -u qbtorinfosequentialedit
     return 1
    else
     if [ -z "$QBhash" ]
        then
         >&2 echo No torrent is selected
         return 1
        else
         local se="$1"
         local fl="$1"
         if [ $# -gt 1 ]
            then fl="$2"
         fi
         local oldval=$(__META_qbrequest "torrents/info?hashes=$QBhash" 2>/dev/null | jq -rc '.[] | [ .seq_dl, .f_l_piece_prio ]' 2>/dev/null)
         if [ -z "$oldval" ]
            then
             >&2 echo 'An error is occured'
             return 1
         fi
         local oldse=$(echo "$oldval" | jq -r '.[0]')
         local oldfl=$(echo "$oldval" | jq -r '.[1]')
         [ "$se" == "$oldse" ] || __META_qbrequest "torrents/toggleSequentialDownload?hashes=$QBhash" >/dev/null
         [ "$fl" == "$oldfl" ] || __META_qbrequest "torrents/toggleFirstLastPiecePrio?hashes=$QBhash" >/dev/null
     fi
fi
}

# qbtorblock: Scaled piece states string
# Usage: qbtorblock [-n [NUMBER_OF_BLOCKS]] [(-o FILE_INDEX | -i FILE_INDEX1 [FILE_INDEX2])]
# qbtorblock: Print a fixed number of symbols showing the state of pieces blocks of the selected torrent.
# qbtorblock: Without the "-n" options the number of blocks equals to $COLUMNS (of the current terminal).
# qbtorblock: If the option "-n" is present then the default number equals to the number of pieces of the torrent (so block=piece). 
# qbtorblock: The meaning of symbols:
# qbtorblock: "#" - completely downloaded block
# qbtorblock: "+" - partially downloaded block
# qbtorblock: "v" - downloading block
# qbtorblock: "-" - not downloaded (empty) block
# qbtorblock: The option "-o" specifies the index of a file, whose only pieces will be shown.
# qbtorblock: The option "-i" specifies the qbtorcontent interval of file indices whose pieces will be shown among other pieces. The pieces of files outside the interval will be marked by the dot (".")

alias qbtorblock="__META_qbcall qbtorblock"
function __META_qbtorblock ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
local aone="$COLUMNS"
if [ "$1" == "-n" ]
    then
     if [ "x${2:0:1}" == "x-" ]
        then
         aone=""
        else
         aone="$2"
         shift
     fi
     shift
fi
if [ "$1" == "-o" ]
    then
     local pi=$(__META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null |
     jq --arg i "$2" 'sort_by(.name)|.[($i|tonumber)].piece_range')
     if [ -z "$aone" ]
        then
         __META_qbrequest "torrents/pieceStates?hash=$QBhash" 2>/dev/null |
         jq -r --argjson pi "$pi" '.[$pi|.[0]:($pi|.[1])+1]|[.[]|if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
        else
         __META_qbrequest "torrents/pieceStates?hash=$QBhash" 2>/dev/null |
         jq -r --argjson pi "$pi" --arg aone "$aone" '.[$pi|.[0]:($pi|.[1])+1]|
         length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
         [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
         reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
         if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
     fi
    else
     if [ "$1" == "-i" ]
        then
         local arg3="$3"
         if [ -z $arg3 ]
            then
             arg3="$2"
         fi
         pi=$(__META_qbrequest "torrents/files?hash=$QBhash"  2>/dev/null |
         jq -c --arg i "$2" --arg j "$arg3" 'sort_by(.name) as $inp|reduce range($i|tonumber;($j|tonumber)+1) as $n ([];.+[($inp|.[$n]).piece_range|range(.[0];.[1]+1)]|unique)')
         if [ -z "$aone" ]
            then
             __META_qbrequest "torrents/pieceStates?hash=$QBhash" 2>/dev/null |
             jq -r --argjson pi "$pi" '. as $inp|length as $len| [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             __META_qbrequest "torrents/pieceStates?hash=$QBhash" 2>/dev/null |
             jq -r --argjson pi "$pi" --arg aone "$aone" '. as $inp|length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|
             [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end]|
             [.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
        fi
        else
         if [ -z "$aone" ]
            then
             __META_qbrequest "torrents/pieceStates?hash=$QBhash" 2>/dev/null |
             jq -r '[.[]|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             __META_qbrequest "torrents/pieceStates?hash=$QBhash" 2>/dev/null |
             jq -r --arg aone "$aone" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
         fi
     fi
fi
     #jq --argjson pi "$pi" '. as $inp|[range($pi|.[0];($pi|.[1])+1)]|.[]| . as $ind | $inp|.[$ind]'
     #|.[]|. as $ind|($inp|.[$ind])]'

     #jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | .['"$1"'].key'
     #curl "${QBarg[@]}" -s  --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq '.['"$index"']
#fi
#curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
#jq -r --arg aone "$1" ""'[length as $len|($aone|tonumber) as $size|to_entries |[.[]|{ "a":(.key*$size/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
}


# qbtorgeneral: Get the specified general properties of the selected torrent, or print all of them
# Usage: qbtorgeneral [(-r GEN_PROPERTY | GEN_PROPERTY_1 [GEN_PROPERTY_2 ...])]

alias qbtorgeneral="__META_qbcall qbtorgeneral"
function __META_qbtorgeneral ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         >&2 qbhelp -u qbtorgeneral
         return 127
     fi
     __META_qbrequest "torrents/properties?hash=$QBhash" 2>/dev/null| jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     __META_qbrequest "torrents/properties?hash=$QBhash" 2>/dev/null | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     __META_qbrequest "torrents/properties?hash=$QBhash" 2>/dev/null | jq "$jj"
fi
return 0
}




# qbtortrack: Trackers info of the selected torrent
# Usage: qbtortrack

alias qbtortrack="__META_qbcall qbtortrack"
function __META_qbtortrack ()
{
if [ -z "$QBhash" ]
then
>&2 echo 'No torrent is selected'
else
__META_qbrequest "torrents/trackers?hash=$QBhash" 2>/dev/null |
jq '.[]|.url+" ("+
(.status|if .==0 then "Disabled" else if .==1 then "Not contacted" else if .==2 then "Working" else if .==3 then "Updating" else "Not working" end end end end)+
"), p:"+(.num_peers|tostring)+" s:"+(.num_seeds|tostring)+" l:"+(.num_leeches|tostring)'
fi
}

# qbtortrackedit: Edit trackers of the selected torrent
# Usage: qbtortrackedit (-d URL | URL_1 [URL_2])
# qbtortrackedit: Options:
# qbtortrackedit: -d URL - Delete the tracker URL
# qbtortrackedit:  URL_1 [URL_2] - Add the tracker URL_1, or replace URL_2 by URL_1

alias qbtortrackedit="__META_qbcall qbtortrackedit"
function __META_qbtortrackedit ()
{
local resp
local url1=$(echo "$1"|jq -rR '@uri')
local url2=$(echo "$2"|jq -rR '@uri')
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtortrackedit
     return 127
fi
if [ "$1" == "-d" ]
    then
     if [ -z "$2" ]
      then
       >&2 qbhelp -u qbtortrackedit
       return 127
      else
       resp=$(__META_qbrequest -e "torrents/removeTrackers?hash=$QBhash&urls=$url2" 2>/dev/null)
     fi
    else
     if [ -z "$2" ]
        then
         resp=$(__META_qbrequest -e "torrents/addTrackers?hash=$QBhash&urls=$url1" 2>/dev/null)
        else
         resp=$(__META_qbrequest -e "torrents/editTracker?hash=$QBhash&origUrl=$url2&newUrl=$url1" 2>/dev/null)
     fi
fi
if [ "$resp" != 200 ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
}





# qbtorpeer: List of connected peers of the selected torrent with a short info
# Usage: qbtorpeer

alias qbtorpeer="__META_qbcall qbtorpeer"
function __META_qbtorpeer ()
{
if [ -z "$QBhash" ]
then
>&2 echo No torrent is selected
return 1
else
__META_qbrequest "sync/torrentPeers?hash=$QBhash" 2>/dev/null| jq '[.peers | .[]] | sort_by(.progress) |.[] |
(.progress*100 | trunc | tostring)+"% "+.ip+" "+.country_code+" "+(.dl_speed /1024 |trunc|tostring)+"Kb/s "+.client+"("+.connection+")"'
fi
}

# qbtorpeeradd: Add a peer
# Usage: qbtorpeeradd PEER

alias qbtorpeeradd="__META_qbcall qbtorpeeradd"
function __META_qbtorpeeradd ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtorpeeradd
     return 127
fi
local resp=$(__META_qbrequest -e "torrents/addPeers?hashes=$QBhash&peers=$1" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     if [ "$resp" == 400 ]
        then
         >&2 echo 'The peer is not valid'
        else
         >&2 echo 'An error is occured'
     fi
     return 1
fi
return 0
}




# qbtorcontent: List the files of the selected torrent with a short info
# Usage: qbtorcontent [FILE_INDEX_1] [FILE_INDEX_2]
# qbtorcontent: Without arguments list all files of the selected torrent in the alphabetical order with a short info. 
# qbtorcontent: If FILE_INDEX1 is indicated then the list starts with this index and finishes at FILE_INDEX2. 
# qbtorcontent: If no FILE_INDEX2 or FILE_INDEX2<FILE_INDEX1 the list contains only one item.

alias qbtorcontent="__META_qbcall qbtorcontent"
function __META_qbtorcontent ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo "No torrent is selected"
     return 1
fi
local arg2
local filter='(.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+(.value.size /1048576|trunc|tostring)+"Mb, "+(.value.availability*100|trunc|tostring)+"% online"'
if [ -z "$1" ]
    then
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null |
     jq "sort_by(.name) |  to_entries | .[] |$filter"
    else
     if [ -z $2 ]
        then arg2="$1"
        else arg2="$2"
     fi
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null |
     jq "sort_by(.name)|to_entries|[.[$1]]+.[$1+1:$arg2+1]|.[]|$filter"
fi
return 0
}

# qbtorfile: Get the info of the specified file of the selected torrent
# Usage: qbtorfile FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]
# qbtorfile: FILE_INDEX corresponds to the output of qbtorcontent

alias qbtorfile="__META_qbcall qbtorfile"
function __META_qbtorfile ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtorfile
     return 127
fi
if [ "$2" == "-r" ]
    then
     if [ -z "$3" ] || [ $# -gt 3 ]
        then
         >&2 qbhelp -u qbtorfile
         return 127
     fi
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null | jq -rc 'sort_by(.name)|.['"$1"']|.'"$3"
     return 0
fi
if [ -z "$2" ]
    then
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null | jq 'sort_by(.name)|.['"$1"']'
    else
     local j="$1"
     shift
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null | jq 'sort_by(.name)|.['"$j"']|'"$jj"
fi
return 0
}


# qbtorfileprio: Show the file priorities of the selected torrent with a short info
# Usage: qbtorfileprio [-r] [FILE_INDEX_1] [FILE_INDEX_2]
# qbtorfileprio: The arguments ARG_1 and ARG2 determine an interval of files similarly with qbtorcontent
# qbtorfileprio: With the "-r" option the function prints only priority values
alias qbtorfileprio="__META_qbcall qbtorfileprio"
function __META_qbtorfileprio ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo "No torrent is selected"
     return 1
fi
local filter
if [ "$1" == "-r" ]
    then
     filter='.value.priority'
     shift
    else
     filter='[{"prio":.value.priority},{"%":(.value.progress*100|trunc)}, (.key|tostring)+". "+.value.name]'
fi
local arg2
if [ -z "$1" ]
    then
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null |
     jq -c 'sort_by(.name) |  to_entries | .[] |'"$filter"
    else
     if [ -z $2 ]
        then arg2="$1"
        else arg2="$2"
     fi
     __META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null |
     jq -c 'sort_by(.name)|to_entries|[.['"$1"']]+.['"$1"'+1:'"$arg2"'+1]|.[]|'"$filter"
fi
return 0
}


# qbtorfileprioedit: Set priority of all files of the selected torrent, or set the priority for the files in the qbcontent() interval
# Usage: qbtorfileprioedit NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
# qbtorfileprioedit: FILE_INDEX corresponds to the output of qbtorcontent

alias qbtorfileprioedit="__META_qbcall qbtorfileprioedit"
function __META_qbtorfileprioedit ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtorfileprioedit
     return 127
fi
local index=""
local arg3
if [ -z "$2" ]
    then
     index=$(__META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null | jq -r '["0"]+[range(1;length)|tostring|"|"+.]|add' 2>/dev/null)
    else
     if [ -z $3 ]
        then arg3="$2"
        else arg3="$3"
     fi
     index=$(__META_qbrequest "torrents/files?hash=$QBhash" 2>/dev/null |
     jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | [(.['"$2"'].key|tostring)]+ [.['"$2"'+1:'"$arg3"'+1] | "|"+(.[].key|tostring)]|add' 2>/dev/null)
fi
if [ -z "$index" ]
    then
     >&2 echo "An error is occured"
     return 1
fi
local exitcode=$(__META_qbrequest -e "torrents/filePrio?hash=$QBhash&id=$index&priority=$1" 2>/dev/null)
if [ "$exitcode" == "200" ]
    then return 0
    else
     #TODO: add the exitcodes 400, 404,409
     >&2 echo "An error is occured"
     return 1
fi
}


#########################################################################################3=
#The initialization
##########################################################################################

shopt -s expand_aliases
HISTFILE="$HOME/.qbclient_history"
HISTCONTROL="ignoreboth:erasedups"
PROMPT_COMMAND='history -n; history -w; history -c; history -r; PS1=\$QBurl"/"\${QBhash:0:5}"> "'
QBarg=()
[ -z "$QB_arg1" ] || QBarg+=("$QB_arg1")
[ -z "$QB_arg2" ] || QBarg+=("$QB_arg2")
unset QB_arg1
unset QB_arg2
QBlogin="$QB_login"
unset QB_login
QBpassword="$QB_password"
unset QB_password
QBurl="$QB_url"
unset QB_url
__META_qblogin
exitcode=$?
[ "$exitcode" == "0" ] || builtin exit "$exitcode"
unset exitcode
#QBchtime=$(date +%s)
