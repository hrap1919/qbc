#
### Qbittorent shell client
##
##
# qbhelp: qbclient usage help
# qbhelp:
# Usage: qbhelp [(list | [-u] FUNCTION)]
# qbhelp:
# qbhelp: Options:
# qbhelp: list - list of available FUNCTIONs
# qbhelp: -u FUNCTION - the usage of FUNCTION
# qbhelp: FUNCTION - the help for FUNCTION

function qbhelp ()
{
if [ "$1" == "list" ]
    then
     while read line1 line2 line3 line4
        do
         [ "$line1" == "#" ] && [ "$line2" == "Usage:" ] && echo "$line3"
        done < "$QBfuncfile"
    else
     local usage=""
     if [ "$1" == "-u" ]
        then
         usage="yes"
         shift
     fi
     local funct="$1"
     [ -z "$1" ] && funct="qbhelp"
     [ "${funct:0:2}" == "qb" ] || funct="qb$funct"
     while read line1 line2 line3 line4
        do
         if [ "$line1" == "#" ] && [ "$line2" == "Usage:" ] && [ "$line3" == "${funct}" ]
            then
             echo "Usage: $line3 $line4"
            else
             if [ -z "$usage" ] && [ "$line1" == "#" ] && [ "$line2" == "${funct}:" ] 
                then
                 echo "$line3 $line4"
             fi
         fi
        done < "$QBfuncfile"
        [ -z "$usage" ] && echo
fi
}

# Log in to the server
#
## Usage: qblogin [-k] [-p PASSWORD] URL LOGIN

function qb_arg_array ()
{
QBarg=()
[ -z "$QBarg1" ] || QBarg=("$QBarg1")
[ -z "$QBarg2" ] || QBarg+=("$QBarg2")
}


function qblogin () {
if [ ! -z "$QBurl" ]
    then
     echo Already authorized
     return 1
fi
local curlopt1
local curlopt2
if [ "$1" == "-k" ]
    then
     curlopt1="-k"
     curlopt2=""
     shift
    else
     if [ "$1" == "-c" ]
        then
         curlopt1="--cacert"
         curlopt2="$2"
         shift
         shift
        else
         curlopt1=""
         curlopt2=""
     fi
fi
local login
if [ "$1" == "-l" ]
    then
     login="$2"
     shift
     shift
    else
     login="admin"
fi
local password
if [ "$1" == "-p" ]
    then
     password="$2"
     shift
     shift
    else
     password=""
fi
if [ -z "$1" ]
    then
     echo 'Usage: qblogin [(-k | -c CERTFILE)] [-l USERNAME] [-p PASSWORD] URL'
     return 127
fi
if [ -z "$password" ]
    then
     read -rs -p "Password for $login: " password
     echo
fi
QBarg1=$curlopt1
QBarg2=$curlopt2
password=$(echo "$password" | jq  -rR @uri)
login=$(echo "$login" | jq  -rR @uri)
local exitcode=""
qb_arg_array
QBcookie=$(curl "${QBarg[@]}" -i --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null |
while read line1 line2 line3; do [ -z $exitcode ] && { exitcode=$line2; printf "$line2;"; }; [ $line1 == "set-cookie:" ] && printf $line2; done)
exitcode=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line1 ) )
QBcookie=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line2 ) )
#QBcookie=$(curl "${QBarg[@]}" -c - --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null | cut -sf7)
if [ -z "$QBcookie" ]
    then
     if [ "$exitcode" == 200 ]
        then
         echo "Fail. Invalid username/password"
         return 126
        else
         if [ "$exitcode" == 403 ]
            then
             echo "Fail. Your IP is banned"
             return 126
            else
             echo "Fail. Check URL and/or SSL certificate"
             return 1
         fi
     fi
fi
QBurl=$1
QBarg1=$curlopt1
QBarg2=$curlopt2
qb_arg_array
echo Success
}

# Log out
## Usage: qblogout

function qblogout ()
{
if [ -z "$QBurl" ]
    then
     echo "Not logged in"
     return 1
fi
local exitcode=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/auth/logout" 2>/dev/null)
unset QBurl
unset QBcookie
unset QBhash
unset QBarg1
unset QBarg2
unset QBarg

if [ "$exitcode" == 200 ]
    then
     echo Logged out
     return 0
    else
     echo 'Warning: logout with the following cookie did not succeed:'
     echo "$QBcookie"
     return 1
    fi
}


function exit ()
{
if [ -z "$QBurl" ]
    then
     exitcode=0
    else
     local exitcode=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/auth/logout" 2>/dev/null)
     if [ "$exitcode" == "200" ]
        then
         >&2 echo Logged out
         exitcode=0
        else
         >&2 echo 'Warning: logout with the following cookie did not succeed:'
         >&2 echo "$QBcookie"
         exitcode=1
    fi
fi
[ -z "$1" ] || exitcode="$1"
builtin exit "$exitcode"
}

# qbreauth: Re-authorize to the server with the same user/password
# qbreauth:
# Usage: qbreauth
function qbreauth ()
{
if [ ! -z "$QBhash" ] &&  [ ! -z "$QBhashtmp" ]
    then
     echo "$QBhash" > "$QBhashtmp"
fi
exit 98
}


# qbtoradd: Add a torrent by a URL (use quotes), or by a torrent FILE.
# qbtoradd:
# Usage: qbtoradd ( -u 'URL'| -f FILE)  [API_PROP_NAME_1 API_PROP_VALUE_1 [API_PROP_NAME_2 API_PROP_VALUE_2 ...]]
# qbtoradd:
# qbtoradd: Each OPTION has the form ARG=VALUE for ARGs listed in WebUI API https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#add-new-torrent

function qbtoradd ()
{
local datarray=("${QBarg[@]}")
local tmptorrent=""
if [ "$1" == "-u" ]
    then
     datarray+=("-F" "urls=$2")
    else
     if [ "$1" == "-f" ]
        then
         datarray+=("-F" "torrents=@$2")
        else
         echo 'qbtoradd ( -u URL| -f FILE)  [API_PROP_NAME_1 API_PROP_VALUE_1 [API_PROP_NAME_2 API_PROP_VALUE_2 ...]]'
         return 127
     fi
fi
shift
shift
while [ ! -z "$1" ]
    do
     datarray+=("-F" "$1")
     shift
    done
curl "${datarray[@]}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
echo
}

# qbprefget: Get the value of specified prefernce property, or print all preferences
# qbprefget:
# Usage: qbprefget [(-r PREF_PROPERTY | PREF_PROPERTY_1 [PREF_PROPERTY_2 ...])]
# qbprefget:
# qbprefget: With the "-r" option the function returns the raw value of a property

function qbprefget ()
{
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         echo 'Usage: qbprefget [(-r PREF_PROPERTY | PREF_PROPERTY_1 [PREF_PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq "$jj"
fi
return 0
}

# qbprefset: Send new values of specified preference properties
# qbprefset:
# Usage: qbprefset [-s] [-n] PREF_PROPERTY_1 NEW_VALUE_1 [PREF_PROPERTY_2 NEW_VALUE_2 ...]
# qbprefset:
# qbprefset: The option -n prevents an additional check the values from the server after the request. The option "-s" forces "-n" and also prevents any output or user confirmations except (may be) error messages

function qbprefset ()
{
local silent="false"
local nocheck="false"
local strval=""
if  [ "$1" == "-s" ]
    then
     silent="true"
     nocheck="true"
     shift
fi
if  [ "$1" == "-n" ]
    then
     nocheck="true"
     shift
fi
if [ -z $1 ]
    then
     echo 'Usage: qbprefset [-s] [-n] PREF_PROPERTY_1 NEW_VALUE_1 [PREF_PROPERTY_2 NEW_VALUE_2 ...]'
     return 127
fi
local pref=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences")
local j='{}'
while [ ! -z "$1" ]
    do
     local t2=$(echo $pref| jq ".$1")
     if [ ${t2:0:1} == '"' ]
        then
         j=$(echo "$j" | jq -c --arg k "$1" --arg v "$2" '.+([ { "key" : $k, "value": $v } ] | from_entries)')
        else
         j=$(echo "$j" | jq -c --arg k "$1" '.+([ { "key" : $k, "value":'"$2"' } ] | from_entries)')
     fi
     shift
     shift
    done
local resp=''
local jj=''
if [ "$silent" == "false" ]
    then
     jj=$(echo $j | jq -r 'to_entries|"{"+([.[]|"\""+.key+"\":"+"."+.key+","]|add|.[0:length-1])+"}"')
     echo 'Old preferences:'
     echo $pref| jq $jj
     echo 'New preferences:'
     echo $j | jq
     read -r -p 'Type "yes" to send the new preferences to the server: ' resp
     if [ "$resp" != "yes" ]
        then
         echo 'Cancelled'
         return 1
     fi
fi
resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/app/setPreferences" --data-urlencode "json=$j" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     echo 'An error is occured'
     return 1
fi
if [ "$nocheck" == "false" ]
    then
     local pref=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences")
     echo 'Just checked preferences:'
     echo $pref| jq $jj
    else
     if [ "$silent" == "false" ]
        then
         echo 'The preferences were sent'
     fi
fi
}

# qbpasswd: Change WebUI password
# qbpasswd:
# Usage: qbpasswd

function qbpasswd ()
{
local newpasswd
local newpasswd1
read -rs -p "New password: " newpasswd
echo
read -rs -p "Retype new password: " newpasswd1
echo
if [ "$newpasswd" == "$newpasswd1" ]
    then
     newpasswd='json='$(echo {} | jq --arg pass "$newpasswd" '{ "web_ui_password": $pass }')
     local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/app/setPreferences" --data-urlencode "$newpasswd" 2>/dev/null)
     if [ "$resp" != "200" ]
        then
         echo 'An error is occured'
        else
         echo 'The password was sent'
     fi
    else
     echo 'Different passwords'
fi
}

# qbinfo: List of torrents with a short info. The torrents are sorted by the addition time. The new torrents always in the end
# qbinfo:
# Usage: qbinfo

function qbinfo ()
{
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq 'to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+(.value.size /1048576|trunc|tostring)+"Mb, state:"+.value.state'
}

# qbselect: Select the torrent with the specified index from qbinfo ()
# qbselect:
# Usage: qbselect [-s] [INDEX]
# qbselect:
# qbselect: Option -s: silent mode

function qbselect ()
{
local silent
if  [ "$1" == "-s" ]
then
silent="yes"
shift
else
silent=""
fi
if [ "x$1" == "x" ] && [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" != "x" ]
then
QBhash=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
fi
if [ "x$silent" == "x" ]
then
echo Torrent with hash="$QBhash" is selected
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq '.[] | .name+", "+(.progress*100|trunc|tostring)+"% of "+(.size /1048576|trunc|tostring)+"Mb, state:"+.state'
fi
fi
}

# qbdel: Delete the selected torrent. The correct index from qbinfo () must be specifies.
# qbdel:
# Usage: qbdel INDEX

function qbdel ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
local checkhash=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
if [ "$QBhash" == "$checkhash" ]
then
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/delete?hashes=$QBhash&deleteFiles=true" 
unset QBhash
else
echo The selected hash $QBhash differ for the hash of $1
fi
fi
}

# qbtorinfo: Get the specified information of the selected torrent, or print it completely
# qbtorinfo:
# Usage: qbtorinfo [(-r INFO_PROPERTY | INFO_PROPERTY_1 [INFO_PROPERTY_2 ...])]

function qbtorinfo ()
{
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         echo 'Usage: qbtorinfo [(-r INFO_PROPERTY | INFO_PROPERTY_1 [INFO_PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -r ".[]|.$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq ".[]"
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq ".[]|$jj"
fi
return 0
}

# qbtorprop: Get the specified property of the selected torrent, or print all it's properties
# qbtorprop:
# Usage: qbtorprop [(-r GEN_PROPERTY | GEN_PROPERTY_1 [GEN_PROPERTY_2 ...])]

function qbtorprop ()
{
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         echo 'Usage: qbtorprop [(-r GEN_PROPERTY | GEN_PROPERTY_1 [GEN_PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq "$jj"
fi
return 0
}

# qbtrackers: Trackers info of the selected torrent
# qbtrackers:
# Usage: qbtrackers

function qbtrackers ()
{
if [ -z "$QBhash" ]
then
echo 'No torrent is selected'
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/trackers?hash=$QBhash" |
jq '.[]|.url+" ("+
(.status|if .==0 then "Disabled" else if .==1 then "Not contacted" else if .==2 then "Working" else if .==3 then "Updating" else "Not working" end end end end)+
"), p:"+(.num_peers|tostring)+" s:"+(.num_seeds|tostring)+" l:"+(.num_leeches|tostring)'
fi
}

# qbtrackedit: Edit trackers of the selected torrent
# qbtrackedit:
# Usage: qbtrackedit (-d URL | URL_1 [URL_2])
# qbtrackedit:
# qbtrackedit: Options:
# qbtrackedit: -d URL - Delete the tracker URL
# qbtrackedit:  URL_1 [URL_2] - Add the tracker URL_1, or replace URL_2 by URL_1

function qbtrackedit ()
{
local resp
local url1=$(echo "$1"|jq -rR '@uri')
local url2=$(echo "$2"|jq -rR '@uri')
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     qbhelp -u qbtrackedit
     return 127
fi
if [ "$1" == "-d" ]
    then
     if [ -z "$2" ]
      then
       qbhelp -u qbtrackedit
       return 127
      else
       resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/removeTrackers?hash=$QBhash&urls=$url2" 2>/dev/null)
     fi
    else
     if [ -z "$2" ]
        then
         resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/addTrackers?hash=$QBhash&urls=$url1" 2>/dev/null)
        else
         resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/editTracker?hash=$QBhash&origUrl=$url2&newUrl=$url1" 2>/dev/null)
     fi
fi
if [ "$resp" != 200 ]
    then
     echo 'An error is occured'
     return 1
fi
return 0
}


# qbcommand: Pause, resume, recheck and reannounce of the selected torrent
# qbcommand:
# Usage: qbcommand (pause | resume | recheck | reannounce)

function qbcommand ()
{
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo 'Usage: qbcommand COMMAND'
     echo 'COMMAND = pause, resume, recheck, reannounce'
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/$1?hashes=$QBhash" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     echo 'An error is occured'
     return 1
fi
return 0
}


# qbpeeradd: Add a peer
# qbpeeradd:
# Usage: qbpeeradd PEER

function qbpeeradd ()
{
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo 'Usage: qbaddpeer PEER'
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/addPeers?hashes=$QBhash&peers=$1" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     if [ "$resp" == 400 ]
        then
         echo 'The peer is not valid'
        else
         echo 'An error is occured'
     fi
     return 1
fi
return 0
}


# qbmedia: Control of Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# qbmedia:
# Usage: qbmedia ARG1 [ARG2]
# qbmedia:
# qbmedia: Set Sequential_Download property of the selected torrent to ARG1. Set First_Last_Piece_Priority property either to ARG2, or to ARG1 (if ARG2 is absent). Each of ARG1 and ARG2 must be equal to either "true" or "false"

function qbmedia ()
{
if [ $# -lt 1 ]
    then
     echo 'Usage: qbmedia ARG1 [ARG2]'
    else
     if [ -z "$QBhash" ]
        then
         echo No torrent is selected
        else
         local se="$1"
         local fl="$1"
         if [ $# -gt 1 ]
            then fl="$2"
         fi
         local oldval=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -rc '.[] | [ .seq_dl, .f_l_piece_prio ]')
         local oldse=$(echo "$oldval" | jq -r '.[0]')
         local oldfl=$(echo "$oldval" | jq -r '.[1]')
         [ "$se" == "$oldse" ] || curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleSequentialDownload?hashes=$QBhash"
         [ "$fl" == "$oldfl" ] || curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleFirstLastPiecePrio?hashes=$QBhash"
     fi
fi
}

# qblocationset: Set new location of downloaded files of the selected torrent
# qblocationset:
# Usage: qblocationset NEW_LOCATION

function qblocationset ()
{
if [ -z "$QBhash"  ]
then
echo No torrent is selected
else
if [ -z "$1" ]
then
echo Usage: qbsetlocation NEW_LOCATION
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/setLocation?hashes=$QBhash&location=$1"
fi
fi
}

# qbpeers: Peers info of the selected torrent
# qbpeers:
# Usage: qbpeers

function qbpeers ()
{
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/sync/torrentPeers?hash=$QBhash"| jq '[.peers | .[]] | sort_by(.progress) |.[] | (.progress*100 | trunc | tostring)+"% "+.ip+" "+.country_code+" "+(.dl_speed /1024 |trunc|tostring)+"Kb/s "+.client+"("+.connection+")"'
fi
}



# qbpieceview: Scaled piece states string
# qbpieceview:
# Usage: qbpieceview [-n [NUMBER_OF_BLOCKS]] [(-o FILE_INDEX | -i FILE_INDEX1 [FILE_INDEX2])]
# qbpieceview:
# qbpieceview: Print a fixed number of symbols showing the state of pieces blocks of the selected torrent.
# qbpieceview: Without the "-n" options the number of blocks equals to $COLUMNS (of the current terminal).
# qbpieceview: If the option "-n" is present then the default number equals to the number of pieces of the torrent (so block=piece). 
# qbpieceview: The meaning of symbols:
# qbpieceview:
# qbpieceview: "#" - completely downloaded block
# qbpieceview:
# qbpieceview: "+" - partially downloaded block
# qbpieceview:
# qbpieceview: "v" - downloading block
# qbpieceview:
# qbpieceview: "-" - not downloaded (empty) block
# qbpieceview:
# qbpieceview: The option "-o" specifies the index of a file, whose only pieces will be shown.
# qbpieceview: The option "-i" specifies the interval of file indices whose pieces will be shown among other pieces. The pieces of files outside the interval will be marked by the dot (".")

function qbpieceview ()
{
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
local aone="$COLUMNS"
if [ "$1" == "-n" ]
    then
     if [ "x${2:0:1}" == "x-" ]
        then
         aone=""
        else
         aone="$2"
         shift
     fi
     shift
fi
if [ "$1" == "-o" ]
    then
     local pi=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
     jq --arg i "$2" 'sort_by(.name)|.[($i|tonumber)].piece_range')
     if [ -z "$aone" ]
        then
         curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" '.[$pi|.[0]:($pi|.[1])+1]|[.[]|if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
        else
         curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" --arg aone "$aone" '.[$pi|.[0]:($pi|.[1])+1]|
         length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
         [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
         reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
         if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
     fi
    else
     if [ "$1" == "-i" ]
        then
         local arg3="$3"
         if [ -z $arg3 ]
            then
             arg3="$2"
         fi
         pi=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
         jq -c --arg i "$2" --arg j "$arg3" 'sort_by(.name) as $inp|reduce range($i|tonumber;($j|tonumber)+1) as $n ([];.+[($inp|.[$n]).piece_range|range(.[0];.[1]+1)]|unique)')
         if [ -z "$aone" ]
            then
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" '. as $inp|length as $len| [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" --arg aone "$aone" '. as $inp|length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|
             [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end]|
             [.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
        fi
        else
         if [ -z "$aone" ]
            then
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r '[.[]|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r --arg aone "$aone" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
         fi
     fi
fi
     #jq --argjson pi "$pi" '. as $inp|[range($pi|.[0];($pi|.[1])+1)]|.[]| . as $ind | $inp|.[$ind]'
     #|.[]|. as $ind|($inp|.[$ind])]'

     #jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | .['"$1"'].key'
     #curl "${QBarg[@]}" -s  --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq '.['"$index"']
#fi
#curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
#jq -r --arg aone "$1" ""'[length as $len|($aone|tonumber) as $size|to_entries |[.[]|{ "a":(.key*$size/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
}



# qbcontent: List the files of the selected torrent with a short info
# qbcontent:
# Usage: qbcontent [FILE_INDEX_1] [FILE_INDEX_2]
# qbcontent:
# qbcontent: Without arguments list all files of the selected torrent in the alphabetical order with a short info. 
# qbcontent: If FILE_INDEX1 is indicated then the list starts with this index and finishes at FILE_INDEX2. 
# qbcontent: If no FILE_INDEX2 or FILE_INDEX2<FILE_INDEX1 the list contains only one item.

function qbcontent ()
{
if [ -z "$QBhash" ]
    then
     echo "No torrent is selected"
     return 1
fi
local arg2
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name) |  to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
    else
     if [ -z $2 ]
        then arg2="$1"
        else arg2="$2"
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name)|to_entries|[.['"$1"']]+.['"$1"'+1:'"$arg2"'+1]|.[]|(.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
fi
return 0
}

# qbfileinfo: Get the info of the specified file of the selected torrent
# qbfileinfo:
# Usage: qbfileinfo FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]
# qbfileinfo:
# qbfileinfo: FILE_INDEX corresponds to the output of qbcontent ()

function qbfileinfo ()
{
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     echo 'Usage: qbfileinfo FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]'
     return 127
fi
if [ "$2" == "-r" ]
    then
     if [ -z "$3" ] || [ $# -gt 3 ]
        then
         echo 'Usage: qbfileinfo FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -rc 'sort_by(.name)|.['"$1"']|.'"$3"
     return 0
fi
if [ -z "$2" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq 'sort_by(.name)|.['"$1"']'
    else
     local j="$1"
     shift
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq 'sort_by(.name)|.['"$j"']|'"$jj"
fi
return 0
}

# qbfileprio: Set priority of all files of the selected torrent, or set the priority for the files in the qbcontent() interval
# qbfileprio:
# Usage: qbfileprio NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
# qbfileprio:
# qbfileprio: FILE_INDEX corresponds to the output of qbcontent ()

function qbfileprio ()
{
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo Usage: qbfileprio NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
     return 127
fi
local index=""
local arg3
if [ -z "$2" ]
    then
     index=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -r '["0"]+[range(1;length)|tostring|"|"+.]|add' 2>/dev/null)
    else
     if [ -z $3 ]
        then arg3="$2"
        else arg3="$3"
     fi
     index=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | [(.['"$2"'].key|tostring)]+ [.['"$2"'+1:'"$arg3"'+1] | "|"+(.[].key|tostring)]|add' 2>/dev/null)
fi
if [ -z "$index" ]
    then
     echo "Fail"
     return 1
fi
local exitcode=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/filePrio?hash=$QBhash&id=$index&priority=$1" 2>/dev/null)
if [ "$exitcode" == "200" ]
    then return 0
    else
     #TODO: add the exitcodes 400, 404,409
     echo "Fail"
     return 1
fi
}

HISTFILE="$HOME/.qbclient_history"
HISTCONTROL="ignoreboth:erasedups"
PROMPT_COMMAND='history -n; history -w; history -c; history -r; PS1=\$QBurl"/"\${QBhash:0:5}"> "'
qb_arg_array
