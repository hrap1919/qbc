#
### Qbittorent shell client
##
##
# Log in to the server
#
# Usage: qblogin [-k] [-p PASSWORD] URL LOGIN

function qb_arg_array ()
{
QBarg=()
[ -z "$QBarg1" ] || QBarg=("$QBarg1")
[ -z "$QBarg2" ] || QBarg+=("$QBarg2")
}


function qblogin () {
if [ ! -z "$QBurl" ]
    then
     echo Already authorized
     return 1
fi
local curlopt1
local curlopt2
if [ "$1" == "-k" ]
    then
     curlopt1="-k"
     curlopt2=""
     shift
    else
     if [ "$1" == "-c" ]
        then
         curlopt1="--cacert"
         curlopt2="$2"
         shift
         shift
        else
         curlopt1=""
         curlopt2=""
     fi
fi
local login
if [ "$1" == "-l" ]
    then
     login="$2"
     shift
     shift
    else
     login="admin"
fi
local password
if [ "$1" == "-p" ]
    then
     password="$2"
     shift
     shift
    else
     password=""
fi
if [ -z "$1" ]
    then
     echo 'Usage: qblogin [(-k | -c CERTFILE)] [-l USERNAME] [-p PASSWORD] URL'
     return 127
fi
if [ -z "$password" ]
    then
     read -rs -p "Password for $login: " password
     echo
fi
QBarg1=$curlopt1
QBarg2=$curlopt2
password=$(echo "$password" | jq  -rR @uri)
login=$(echo "$login" | jq  -rR @uri)
local exitcode=""
qb_arg_array
QBcookie=$(curl "${QBarg[@]}" -i --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null |
while read line1 line2 line3; do [ -z $exitcode ] && { exitcode=$line2; printf "$line2;"; }; [ $line1 == "set-cookie:" ] && printf $line2; done)
exitcode=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line1 ) )
QBcookie=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line2 ) )
#QBcookie=$(curl "${QBarg[@]}" -c - --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null | cut -sf7)
if [ -z "$QBcookie" ]
    then
     if [ "$exitcode" == 200 ]
        then
         echo "Fail. Invalid username/password"
         return 126
        else
         if [ "$exitcode" == 403 ]
            then
             echo "Fail. Your IP is banned"
             return 126
            else
             echo "Fail. Check URL and/or SSL certificate"
             return 1
         fi
     fi
fi
QBurl=$1
QBarg1=$curlopt1
QBarg2=$curlopt2
#QBcookie="SID=$QBcookie"
echo Success
}

# Log out
# Usage: qblogout

function qblogout ()
{
qb_arg_array
if [ -z "$QBurl" ]
    then
     echo "Not logged in"
     return 1
fi
local exitcode=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/auth/logout" 2>/dev/null)
unset QBurl
unset QBcookie
unset QBhash
unset QBarg1
unset QBarg2

if [ "$exitcode" == 200 ]
    then
     echo Logged out
     return 0
    else
     echo 'Warning: logout with the following cookie did not succeed:'
     echo "$QBcookie"
     return 1
    fi
}


# Add torrent
#
# Usage: qbtoradd ( -u 'URL'| -f FILE)  [API_PROP_NAME_1 API_PROP_VALUE_1 [API_PROP_NAME_2 API_PROP_VALUE_2 ...]]
#use quotes in URL

function qbtoradd ()
{
qb_arg_array
local datarray=("${QBarg[@]}")
local tmptorrent=""
if [ "$1" == "-u" ]
    then
     datarray+=("-F" "urls=$2")
    else
     if [ "$1" == "-f" ]
        then
         datarray+=("-F" "torrents=@$2")
        else
         echo 'qbtoradd ( -u URL| -f FILE)  [API_PROP_NAME_1 API_PROP_VALUE_1 [API_PROP_NAME_2 API_PROP_VALUE_2 ...]]'
         return 127
     fi
fi
shift
shift
while [ ! -z "$1" ]
    do
     datarray+=("-F" "$1")
     shift
    done
curl "${datarray[@]}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
echo
}

# Get the value of specified prefernce property, or print all preferences
#
# Usage: qbprefget [(-r PREF_PROPERTY | PREF_PROPERTY_1 [PREF_PROPERTY_2 ...])]

function qbprefget ()
{
qb_arg_array
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         echo 'Usage: qbprefget [(-r PREF_PROPERTY | PREF_PROPERTY_1 [PREF_PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq "$jj"
fi
return 0
}

# Set a new value of the preference property
#
# Usage: qbprefset [-s] [-n] PREF_PROPERTY_1 NEW_VALUE_1 [PREF_PROPERTY_2 NEW_VALUE_2 ...]

function qbprefset ()
{
qb_arg_array
local silent="false"
local nocheck="false"
local strval=""
if  [ "$1" == "-s" ]
    then
     silent="true"
     nocheck="true"
     shift
fi
if  [ "$1" == "-n" ]
    then
     nocheck="true"
     shift
fi
if [ -z $1 ]
    then
     echo 'Usage: qbprefset [-s] [-n] PREF_PROPERTY_1 NEW_VALUE_1 [PREF_PROPERTY_2 NEW_VALUE_2 ...]'
     return 127
fi
local pref=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences")
local j='{}'
while [ ! -z "$1" ]
    do
     local t2=$(echo $pref| jq ".$1")
     if [ ${t2:0:1} == '"' ]
        then
         j=$(echo "$j" | jq -c --arg k "$1" --arg v "$2" '.+([ { "key" : $k, "value": $v } ] | from_entries)')
        else
         j=$(echo "$j" | jq -c --arg k "$1" '.+([ { "key" : $k, "value":'"$2"' } ] | from_entries)')
     fi
     shift
     shift
    done
local resp=''
local jj=''
if [ "$silent" == "false" ]
    then
     jj=$(echo $j | jq -r 'to_entries|"{"+([.[]|"\""+.key+"\":"+"."+.key+","]|add|.[0:length-1])+"}"')
     echo 'Old preferences:'
     echo $pref| jq $jj
     echo 'New preferences:'
     echo $j | jq
     read -r -p 'Type "yes" to send the new preferences to the server: ' resp
     if [ "$resp" != "yes" ]
        then
         echo 'Cancelled'
         return 1
     fi
fi
resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/app/setPreferences" --data-urlencode "json=$j" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     echo 'An error is occured'
     return 1
fi
if [ "$nocheck" == "false" ]
    then
     local pref=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences")
     echo 'Just checked preferences:'
     echo $pref| jq $jj
    else
     if [ "$silent" == "false" ]
        then
         echo 'The preferences were sent'
     fi
fi
}

# Change password
#
# Usage: qbpasswd

function qbpasswd ()
{
qb_arg_array
local newpasswd
local newpasswd1
read -rs -p "New password: " newpasswd
echo
read -rs -p "Retype new password: " newpasswd1
echo
if [ "$newpasswd" == "$newpasswd1" ]
    then
     newpasswd='json='$(echo {} | jq --arg pass "$newpasswd" '{ "web_ui_password": $pass }')
     local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/app/setPreferences" --data-urlencode "$newpasswd" 2>/dev/null)
     if [ "$resp" != "200" ]
        then
         echo 'An error is occured'
        else
         echo 'The password was sent'
     fi
    else
     echo 'Different passwords'
fi
}

# List of torrents with a short info. The torrents are sorted by the addition time. The new torrents always in the end
#
# Usage: qbinfo

function qbinfo ()
{
qb_arg_array
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq 'to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+(.value.size /1048576|trunc|tostring)+"Mb, state:"+.value.state'
}

# Select the torrent with the specified index from qbinfo ()
#
# Usage: qbselect [-s] [INDEX]
# Option -s: silent mode

function qbselect ()
{
qb_arg_array
local silent
if  [ "$1" == "-s" ]
then
silent="yes"
shift
else
silent=""
fi
if [ "x$1" == "x" ] && [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
if [ "x$1" != "x" ]
then
QBhash=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
fi
if [ "x$silent" == "x" ]
then
echo Torrent with hash="$QBhash" is selected
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq '.[] | .name+", "+(.progress*100|trunc|tostring)+"% of "+(.size /1048576|trunc|tostring)+"Mb, state:"+.state'
fi
fi
}

# Delete the selected torrent. The correct index from qbinfo () must be specifies.
#
# Usage: qbdel INDEX

function qbdel ()
{
qb_arg_array
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
local checkhash=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
if [ "$QBhash" == "$checkhash" ]
then
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/delete?hashes=$QBhash&deleteFiles=true" 
unset QBhash
else
echo The selected hash $QBhash differ for the hash of $1
fi
fi
}

# Get the specified information of the selected torrent, or print it completely
#
# Usage: qbtorinfo [(-r INFO_PROPERTY | INFO_PROPERTY_1 [INFO_PROPERTY_2 ...])]

function qbtorinfo ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         echo 'Usage: qbtorinfo [(-r INFO_PROPERTY | INFO_PROPERTY_1 [INFO_PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -r ".[]|.$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq ".[]"
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq ".[]|$jj"
fi
return 0
}

# Get the specified property of the selected torrent, or print all it's properties
#
# Usage: qbtorprop [(-r GEN_PROPERTY | GEN_PROPERTY_1 [GEN_PROPERTY_2 ...])]

function qbtorprop ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         echo 'Usage: qbtorprop [(-r GEN_PROPERTY | GEN_PROPERTY_1 [GEN_PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq "$jj"
fi
return 0
}

# Trackers info of the selected torrent
#
# Usage: qbtrackers

function qbtrackers ()
{
qb_arg_array
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/trackers?hash=$QBhash" | jq '.[]'
fi
}

# Pause, resume, recheck and reannounce of the selected torrent
#
# Usage: qbcommand COMMAND
# COMMAND = pause, resume, recheck, reannounce

function qbcommand ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo 'Usage: qbcommand COMMAND'
     echo 'COMMAND = pause, resume, recheck, reannounce'
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/$1?hashes=$QBhash" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     echo 'An error is occured'
     return 1
fi
return 0
}


# Add peer
#
# Usage: qbpeeradd PEER

function qbpeeradd ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo 'Usage: qbaddpeer PEER'
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/addPeers?hashes=$QBhash&peers=$1" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     if [ "$resp" == 400 ]
        then
         echo 'The peer is not valid'
        else
         echo 'An error is occured'
     fi
     return 1
fi
return 0
}


# Toggle Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# Usage: qbmedia ARG1 [ARG2]

function qbmedia ()
{
qb_arg_array
if [ $# -lt 1 ]
    then
     echo 'Usage: qbmedia ARG1 [ARG2]'
    else
     if [ -z "$QBhash" ]
        then
         echo No torrent is selected
        else
         local se="$1"
         local fl="$1"
         if [ $# -gt 1 ]
            then fl="$2"
         fi
         local oldval=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -rc '.[] | [ .seq_dl, .f_l_piece_prio ]')
         local oldse=$(echo "$oldval" | jq -r '.[0]')
         local oldfl=$(echo "$oldval" | jq -r '.[1]')
         [ "$se" == "$oldse" ] || curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleSequentialDownload?hashes=$QBhash"
         [ "$fl" == "$oldfl" ] || curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleFirstLastPiecePrio?hashes=$QBhash"
     fi
fi
}

# Set new location of downloaded files of the selected torrent
#
# Usage: qblocationset NEW_LOCATION

function qblocationset ()
{
qb_arg_array
if [ -z "$QBhash"  ]
then
echo No torrent is selected
else
if [ -z "$1" ]
then
echo Usage: qbsetlocation NEW_LOCATION
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/setLocation?hashes=$QBhash&location=$1"
fi
fi
}

# Peers info of the selected torrent
#
# Usage: qbpeers

function qbpeers ()
{
qb_arg_array
if [ "x$QBhash" == "x" ]
then
echo No torrent is selected
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/sync/torrentPeers?hash=$QBhash"| jq '[.peers | .[]] | sort_by(.progress) |.[] | (.progress*100 | trunc | tostring)+"% "+.ip+" "+.country_code+" "+(.dl_speed /1024 |trunc|tostring)+"Kb/s "+.client+"("+.connection+")"'
fi
}



#Scaled pieces state string
#
#Usage: qbpieceview [-n [NUMBER_OF_BLOCKS]] [(-o FILE_INDEX | -i FILE_INDEX1 [FILE_INDEX2])]
function qbpieceview ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
local aone="$COLUMNS"
if [ "$1" == "-n" ]
    then
     if [ "x${2:0:1}" == "x-" ]
        then
         aone=""
        else
         aone="$2"
         shift
     fi
     shift
fi
if [ "$1" == "-o" ]
    then
     local pi=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
     jq --arg i "$2" 'sort_by(.name)|.[($i|tonumber)].piece_range')
     if [ -z "$aone" ]
        then
         curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" '.[$pi|.[0]:($pi|.[1])+1]|[.[]|if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
        else
         curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" --arg aone "$aone" '.[$pi|.[0]:($pi|.[1])+1]|
         length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
         [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
         reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
         if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
     fi
    else
     if [ "$1" == "-i" ]
        then
         local arg3="$3"
         if [ -z $arg3 ]
            then
             arg3="$2"
         fi
         pi=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
         jq -c --arg i "$2" --arg j "$arg3" 'sort_by(.name) as $inp|reduce range($i|tonumber;($j|tonumber)+1) as $n ([];.+[($inp|.[$n]).piece_range|range(.[0];.[1]+1)]|unique)')
         if [ -z "$aone" ]
            then
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" '. as $inp|length as $len| [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" --arg aone "$aone" '. as $inp|length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|
             [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end]|
             [.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
        fi
        else
         if [ -z "$aone" ]
            then
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r '[.[]|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r --arg aone "$aone" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
         fi
     fi
fi
     #jq --argjson pi "$pi" '. as $inp|[range($pi|.[0];($pi|.[1])+1)]|.[]| . as $ind | $inp|.[$ind]'
     #|.[]|. as $ind|($inp|.[$ind])]'

     #jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | .['"$1"'].key'
     #curl "${QBarg[@]}" -s  --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq '.['"$index"']
#fi
#curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
#jq -r --arg aone "$1" ""'[length as $len|($aone|tonumber) as $size|to_entries |[.[]|{ "a":(.key*$size/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
}



# List the files of the selected torrent with a short info
#
# Usage: qbcontent [FILE_INDEX_1] [FILE_INDEX_2]

function qbcontent ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo "No torrent is selected"
     return 1
fi
local arg2
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name) |  to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
    else
     if [ -z $2 ]
        then arg2="$1"
        else arg2="$2"
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name)|to_entries|[.['"$1"']]+.['"$1"'+1:'"$arg2"'+1]|.[]|(.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
fi



return 0
}

# Get the info of the specified file of the selected torrent
#
# Usage: qbfileinfo FILE_INDEX [PROPERTY]
# FILE_INDEX corresponds to the output of qbcontent ()

function qbfileinfo ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     echo 'Usage: qbfileinfo FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]'
     return 127
fi
if [ "$2" == "-r" ]
    then
     if [ -z "$3" ] || [ $# -gt 3 ]
        then
         echo 'Usage: qbfileinfo FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]'
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -rc 'sort_by(.name)|.['"$1"']|.'"$3"
     return 0
fi
if [ -z "$2" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq 'sort_by(.name)|.['"$1"']'
    else
     local j="$1"
     shift
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq 'sort_by(.name)|.['"$j"']|'"$jj"
fi
return 0
}

# Set priority of the specified file of the selected torrent, or set the priority for all it's files
#
# Usage: qbfileprio NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
# FILE_INDEX corresponds to the output of qbcontent ()

function qbfileprio ()
{
qb_arg_array
if [ -z "$QBhash" ]
    then
     echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     echo Usage: qbfileprio NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
     return 127
fi
local index=""
local arg3
if [ -z "$2" ]
    then
     index=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -r '["0"]+[range(1;length)|tostring|"|"+.]|add' 2>/dev/null)
    else
     if [ -z $3 ]
        then arg3="$2"
        else arg3="$3"
     fi
     index=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | [(.['"$2"'].key|tostring)]+ [.['"$2"'+1:'"$arg3"'+1] | "|"+(.[].key|tostring)]|add' 2>/dev/null)
fi
if [ -z "$index" ]
    then
     echo "Fail"
     return 1
fi
local exitcode=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/filePrio?hash=$QBhash&id=$index&priority=$1" 2>/dev/null)
if [ "$exitcode" == "200" ]
    then return 0
    else
     #TODO: add the exitcodes 400, 404,409
     echo "Fail"
     return 1
fi
}

##### Experimental functions not declared in Qbittorrent WebAPI

# Download torrent file of selected torrent to $1
# The variable $local_path must be set up in the code below
#
# Usage: qb_get_torrent_file [FILE_NAME]

function qb_get_torrent_file ()
{
qb_arg_array
# The $localpath is the share folder of the server. Usually it is ~/.local/share/qBittorrent
# It must contain simlink "BT_backup"->"public"
# Rename "BT_backup" to "public" and make such a simlink on the server side
local local_path="/home/user/.local/share/qBittorrent"
#
if [ "x$QBhash" == "x" ]
    then
     echo No torrent is selected
    else
     local save_file
     if [ "x$1" == "x" ]
        then
         save_path="$(qbtorinfo name).torrent"
        else
         save_path="$1"
     fi
     if [ -f "$save_path" ]
        then
         echo File "$save_path" already exists
        else
         local alternative_webui_enabled=$(qbprefget alternative_webui_enabled)
         local alternative_webui_path=$(qbprefget alternative_webui_path)
         qbprefset alternative_webui_path \""$local_path"\"
         qbprefset alternative_webui_enabled true
         curl "${QBarg[@]}" -s --cookie $QBcookie "$QBurl/$QBhash.torrent" --output "$save_path"
         qbprefset alternative_webui_enabled "$alternative_webui_enabled"
         qbprefset alternative_webui_path \""$alternative_webui_path"\"
         if [ -f "$save_path" ]
            then
             echo  File "$save_path" sucessfully downloaded
            else
             echo An error is occurred $save_file
         fi
      fi
fi
}

# Add url into the torrent client ensuring that the actual download will be paused
#
# Usage: qb_add_url_paused "URL" (use quotes!)

function qb_add_url_paused ()
{
qb_arg_array
local response=$(curl "${QBarg[@]}" -F "urls=$1" -F "dlLimit=50000" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add" 2>/dev/null)
if [ $response == "Ok." ]
then
QBhash=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on&reverse=true" | jq -r '.[0].hash')
local state=metaDL
echo; echo Downloading metadata...
while [ $state == "metaDL" ]
    do
     state=$(qbtorinfo state)
    done
qb_get_torrent_file $QBhash.torrent > /dev/null
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/delete?hashes=$QBhash&deleteFiles=true"
curl "${QBarg[@]}" -F 'torrents=@'"$QBhash.torrent" -F "paused=true" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
rm $QBhash.torrent
echo
else
echo An error is occurred
fi
}

#generic curl call
function qbcurl ()
{
qb_arg_array
curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/$1"
echo
}


#jq '[length as $len|to_entries |[.[]|{ "a":(.key*100/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 or (.==2 and $n!=2) then $n else if $n==1 then 1 else . end end)|tostring]|add'

 #qbcurl "torrents/pieceStates?hash=$QBhash" | jq -r --arg aone "$arg" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
 #[to_entries |[.[]|{"a":(.key*$size*$mult/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
 #reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
