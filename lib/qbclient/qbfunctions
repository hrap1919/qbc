#
### Qbittorent shell client
##
##
function exit ()
{
{ 2>&3 curl "${QBarg[@]}" -s --cookie $QBcookie "${QBurl}/api/v2/auth/logout" &>/dev/null & } 3>&2 2>/dev/null
disown &>/dev/null
local exitcode=0
[ -z "$1" ] || exitcode="$1"
builtin exit "$exitcode"
}


function __META_qblogin ()
{
local exitcode=""
local password=$(echo "$QBpassword" | $QBdecode)
QBcookie=$(curl "${QBarg[@]}" -i --header "Referer: $QBurl" --data "username=$QBlogin&password=$(echo $QBpassword|base64 -d|gzip -d|base64 -d|cut -d' ' -f2)" "$QBurl/api/v2/auth/login" 2>/dev/null |
while read line1 line2 line3; do [ -z $exitcode ] && { exitcode=$line2; printf "$line2;"; }; [ $line1 == "set-cookie:" ] && printf $line2; done)
exitcode=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line1 ) )
QBcookie=$(echo $QBcookie | ( IFS=";"; read line1 line2; echo $line2 ) )
#QBcookie=$(curl "${QBarg[@]}" -c - --header "Referer: $1" --data "username=$login&password=$password" "$1/api/v2/auth/login" 2>/dev/null | cut -sf7)
if [ -z "$QBcookie" ]
    then
     if [ "$exitcode" == 200 ]
        then
         >&2 echo "Fail. Invalid username/password"
         return 126
        else
         if [ "$exitcode" == 403 ]
            then
             >&2 echo "Fail. Your IP is banned"
             return 126
            else
             >&2 echo "Fail. Check URL and/or SSL certificate"
             return 1
         fi
     fi
fi
return 0
}

function __META_qbcall ()
{
if [ "$2" == "-h" ]
    then
     __META_qbhelp -u "$1"
    else
     if [ "$2" == "--help" ]
        then
         __META_qbhelp "$1"
        else
         local func="$1"
         shift
         if [ "$func" != "qbhelp" ] && [ "$(($(date +%s)-$QBchtime))" -ge "5" ]
            then
             resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/app/version" 2>/dev/null)
             if [ "$resp" != "200" ]
                then
                 __META_qblogin
                 exitcode=$?
                 [ "$exitcode" == "0" ] || builtin exit "$exitcode"
             fi
             QBchtime=$(date +%s)
         fi
         "__META_$func" "$@"
     fi
fi
}




# qbhelp: qbclient usage help
# Usage: qbhelp [(list | [-u] FUNCTION)]
# Usage:qbhelp Usage: FUNCTION (-h|--help)
# qbhelp: Options:
# qbhelp: list - list of available FUNCTIONs
# qbhelp: -u FUNCTION - the usage of FUNCTION
# qbhelp: FUNCTION - the help for FUNCTION

alias qbhelp="__META_qbcall qbhelp"
function __META_qbhelp ()
{
if [ "$1" == "list" ]
    then
     while read line1 line2 line3 line4
        do
         [ "$line1" == "#" ] && [ "$line2" == "Usage:" ] && echo "$line3"
        done < "$BASH_ENV"
    else
     local usage=""
     if [ "$1" == "-u" ]
        then
         usage="yes"
         shift
     fi
     local funct="$1"
     [ -z "$1" ] && funct="qbhelp"
     [ "${funct:0:2}" == "qb" ] || funct="qb$funct"
     while read line1 line2 line3 line4
        do
         if [ "$line1" == "#" ] && [ "$line2" == "Usage:" ] && [ "$line3" == "${funct}" ]
            then
             echo "Usage: $line3 $line4"
             echo
            else
             if  {
                  [ "$line1" == "#" ] && [ "$line2" == "Usage:${funct}" ]
                 } ||
                 {
                  [ -z "$usage" ] && [ "$line1" == "#" ] && [ "$line2" == "${funct}:" ]
                 }
                then
                 echo "$line3 $line4"
                 echo
             fi
         fi
        done < "$BASH_ENV"
fi
}


# qbversion: print the versions of used software
# Usage: qbversion [(app|api|build [qt|libtorrent|boost|openssl|bitness])]
alias qbversion="__META_qbcall qbversion"
function __META_qbversion ()
{
if [ -z "$1" ]
    then
     echo "Early pre-alpha"
     return 0
fi
resp="null"
if [ "$1" == "app" ]
    then
     resp=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/app/version" 2>/dev/null)
    else
     if [ "$1" == "api" ]
      then
      resp=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/webapiVersion" 2>/dev/null)
     fi
fi
if [ "$1" == "build" ]
    then
     resp=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/buildInfo" 2>/dev/null)
     if [ -z "$resp" ]
        then
         >&2 echo 'An error is occured'
         return 1
     fi
     if [ -z $2 ]
        then
         echo $resp | jq 2>/dev/null
         return 0
        else
         resp=$(echo $resp| jq -r ".$2" 2>/dev/null)
     fi
fi
if [ -z "$resp" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
if [ "$resp" == "null" ]
    then
     >&2 qbhelp -u qbversion
     return 127
    else
     echo $resp
     return 0
fi
}

# qbstatus: Get the current status of the server
# Usage: qbstatus
alias qbstatus="__META_qbcall qbstatus"
function __META_qbstatus ()
{
curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/transfer/info" 2>/dev/null |jq
}

# qbpref: Get the value of specified preference property, or print all preferences
# Usage: qbpref [(-r PREF_PROPERTY | PREF_PROPERTY_1 [PREF_PROPERTY_2 ...])]
# qbpref: With the "-r" option the function returns the raw value of a property

alias qbpref="__META_qbcall qbpref"
function __META_qbpref ()
{
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         >&2 qbhelp -u qbpref
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" | jq "$jj"
fi
return 0
}

# qbprefedit: Send new values of specified preference properties
# Usage: qbprefedit [-s] [-n] PREF_PROPERTY_1 NEW_VALUE_1 [PREF_PROPERTY_2 NEW_VALUE_2 ...]
# qbprefedit: The option -n prevents an additional check the values from the server after the request. The option "-s" forces "-n" and also prevents any output or user confirmations except (may be) error messages
# qbprefedit: To change the WebUI password by a secure way (from stdin) just omit the NEW_VALUE_1 argument in "qbprefedit web_ui_password". A change of web_ui_password property together with another options is not supported.

alias qbprefedit="__META_qbcall qbprefedit"
function __META_qbprefedit ()
{
local silent="false"
local nocheck="false"
local strval=""
if  [ "$1" == "-s" ]
    then
     silent="true"
     nocheck="true"
     shift
fi
if  [ "$1" == "-n" ]
    then
     nocheck="true"
     shift
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbprefedit
     return 127
fi
if [ "$1" == "web_ui_password" ]
then
local newpasswd
local newpasswd1
if [ -z "$2" ]
    then
     read -rs -p "New password: " newpasswd
     echo
     read -rs -p "Retype new password: " newpasswd1
     echo
    else
     newpasswd="$2"
     newpasswd1="$2"
fi
if [ "$newpasswd" == "$newpasswd1" ]
    then
     newpasswd='json='$(echo {} | jq --arg pass "$newpasswd" '{ "web_ui_password": $pass }')
     local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/app/setPreferences" --data-urlencode "$newpasswd" 2>/dev/null)
     if [ "$resp" != "200" ]
        then
         [ "$silent" == "true" ] || >&2 echo 'An error is occured'
         return 1
        else
         [ "$silent" == "true" ] || >&2 echo 'The password was sent'
         return 0
     fi
    else
     >&2 echo 'Different passwords'
     return 1
fi
fi
local pref=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences" 2>/dev/null)
if [ -z "$pref" ]
    then
     >&2 echo 'An error is occured'
    return 1
fi
local j='{}'
while [ ! -z "$1" ]
    do
     if [ "$1" == "web_ui_password" ]
        then
         >&2 echo 'Can not change "web_ui_password" together with other preferences'
         return 1
     fi
     local t2=$(echo $pref| jq ".$1")
     if [ ${t2:0:1} == '"' ]
        then
         j=$(echo "$j" | jq -c --arg k "$1" --arg v "$2" '.+([ { "key" : $k, "value": $v } ] | from_entries)' 2>/dev/null)
        else
         j=$(echo "$j" | jq -c --arg k "$1" '.+([ { "key" : $k, "value":'"$2"' } ] | from_entries)' 2>/dev/null)
     fi
     if [ -z "$j" ]
        then
         [ "$silent" == "true" ] || >&2 echo 'An error is occured'
         return 1
     fi
     shift
     shift
    done
local resp=''
local jj=''
if [ "$silent" == "false" ]
    then
     jj=$(echo $j | jq -r 'to_entries|"{"+([.[]|"\""+.key+"\":"+"."+.key+","]|add|.[0:length-1])+"}"' 2>/dev/null)
     echo 'Old preferences:'
     echo $pref| jq "$jj" 2>/dev/null
     echo 'New preferences:'
     echo $j | jq 2>/dev/null
     read -r -p 'Type "yes" to send the new preferences to the server: ' resp
     if [ "$resp" != "yes" ]
        then
         >&2 echo 'Cancelled'
         return 1
     fi
fi
resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie $QBcookie "${QBurl}/api/v2/app/setPreferences" --data-urlencode "json=$j" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
if [ "$nocheck" == "false" ]
    then
     local pref=$(curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/app/preferences")
     echo 'Just checked preferences:'
     echo $pref| jq $jj 2>/dev/null
    else
     if [ "$silent" == "false" ]
        then
         echo 'The preferences were sent'
     fi
fi
}

# qblist: List of torrents with a short info. The torrents are sorted by the addition time. The new torrents always in the end
# Usage: qblist

alias qblist="__META_qbcall qblist"
function __META_qblist ()
{
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq 'to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+(.value.size /1048576|trunc|tostring)+"Mb, state:"+.value.state'
}


# qblistadd: Add a torrent by a URL (use quotes), or by a torrent FILE.
# Usage: qblistadd ( -u 'URL'| -f FILE)  [ARG_1=VALUE_1 [ARG_2=VALUE_2 ...]]
# qblistadd: The available ARGs are listed in WebUI API https://github.com/qbittorrent/qBittorrent/wiki/WebUI-API-(qBittorrent-4.1)#add-new-torrent

alias qblistadd="__META_qbcall qblistadd"
function __META_qblistadd ()
{
local datarray=("${QBarg[@]}")
local tmptorrent=""
if [ "$1" == "-u" ]
    then
     datarray+=("-F" "urls=$2")
    else
     if [ "$1" == "-f" ]
        then
         datarray+=("-F" "torrents=@$2")
        else
         >&2 qbhelp -u qblistadd
         return 127
     fi
fi
shift
shift
while [ ! -z "$1" ]
    do
     datarray+=("-F" "$1")
     shift
    done
curl "${datarray[@]}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/add"
echo
}


# qblistdelete: Delete the selected torrent.
# Usage: qblistdelete [-d] INDEX
# qblistdelete: The correct INDEX from qblist must be specifies. Option "-d" removes also the downloaded data Delete the selected torrent.

alias qblistdelete="__META_qbcall qblistadd"
function __META_qblistdelete ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
local deldata="false"
if [ "$1" == "-d" ]
    then
     deldata="true"
     shift
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qblistdelete
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash" 2>/dev/null)
if [ "$QBhash" != "$resp" ]
     then
      >&2 echo "The selected hash $QBhash differ for the hash of $1"
      return 1
fi
unset QBhash
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/delete?hashes=$resp&deleteFiles=$deldata"
echo
}

# qblistselect: Select the torrent with the specified index from qblist
# Usage: qblistselect [-s] [INDEX]
# Usage:qblistselect alias qbtorselect=qblistselect
# qblistselect: Option -s: silent mode

alias qblistselect="__META_qbcall qblistselect"
function __META_qblistselect ()
{
local silent
if  [ "$1" == "-s" ]
then
silent="yes"
shift
else
silent=""
fi
if [ "x$1" == "x" ] && [ "x$QBhash" == "x" ]
then
>&2 echo No torrent is selected
return 1
else
if [ "x$1" != "x" ]
then
QBhash=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?sort=added_on" | jq -r ".[$1].hash")
fi
if [ "x$silent" == "x" ]
then
echo Torrent with hash="$QBhash" is selected
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq '.[] | .name+", "+(.progress*100|trunc|tostring)+"% of "+(.size /1048576|trunc|tostring)+"Mb, state:"+.state'
fi
fi
}

# qbtorselect: Select the torrent with the specified index from qblist.
# Usage: qbtorselect [-s] [INDEX]
# Usage:qbtorselect alias qbtorselect=qblistselect
# qbtorselect: Option -s: silent mode

alias qbtorselect=qblistselect


# qbtordo: Pause, resume, recheck and reannounce of the selected torrent
# Usage: qbtordo (pause | resume | recheck | reannounce)
alias qbtordo="__META_qbcall qbtordo"
function __META_qbtordo ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtordo
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/$1?hashes=$QBhash" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
}


# qbtorinfo: Get the specified information of the selected torrent, or print it completely
# Usage: qbtorinfo [(-r INFO_PROPERTY | INFO_PROPERTY_1 [INFO_PROPERTY_2 ...])]

alias qbtorinfo="__META_qbcall qbtorinfo"
function __META_qbtorinfo ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         >&2 qbhelp -u qbtorinfo
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -r ".[]|.$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq ".[]"
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq ".[]|$jj"
fi
return 0
}

# qbtorinfolocation: Show the save location of the selected torrent
# Usage: qbtorinfolocation

alias qbtorinfolocation="__META_qbcall qbtorinfolocation"
function __META_qbtorinfolocation ()
{
qbtorinfo save_path
return $?
}

# qbtorinfolocationedit: Set a new save location of the selected torrent
# Usage: qbtorinfolocationedit NEW_LOCATION
alias qbtorinfolocationedit="__META_qbcall qbtorinfolocationedit"
function __META_qbtorinfolocationedit ()
{
if [ -z "$QBhash"  ]
then
>&2 echo No torrent is selected
return 1
else
if [ -z "$1" ]
then
>&2 qbhelp -u qbtorinfolocationedit
return 1
else
local arg=$(echo $1|jq -rR '@uri')
resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/setLocation?hashes=$QBhash&location=$arg" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
fi
fi
}


# qbtorinfosequential: Show  Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# Usage: qbtorinfosequential
alias qbtorinfosequential="__META_qbcall qbtorinfosequential"
function __META_qbtorinfosequential ()
{
qbtorinfo seq_dl f_l_piece_prio
return $?
}


# qbtorinfosequentialedit: Control of Sequential_Download and First_Last_Piece_Priority properties of the selected torrent
# Usage: qbtorinfosequentialedit ARG1 [ARG2]
# qbtorinfomedia: Set Sequential_Download property of the selected torrent to ARG1. Set First_Last_Piece_Priority property either to ARG2, or to ARG1 (if ARG2 is absent). Each of ARG1 and ARG2 must be equal to either "true" or "false"

alias qbtorinfosequentialedit="__META_qbcall qbtorinfosequentialedit"
function __META_qbtorinfosequentialedit ()
{
if [ $# -lt 1 ]
    then
     >&2 qbhelp -u qbtorinfosequentialedit
     return 1
    else
     if [ -z "$QBhash" ]
        then
         >&2 echo No torrent is selected
         return 1
        else
         local se="$1"
         local fl="$1"
         if [ $# -gt 1 ]
            then fl="$2"
         fi
         local oldval=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/info?hashes=$QBhash" | jq -rc '.[] | [ .seq_dl, .f_l_piece_prio ]' 2>/dev/null)
         if [ -z "$oldval" ]
            then
             >&2 echo 'An error is occured'
             return 1
         fi
         local oldse=$(echo "$oldval" | jq -r '.[0]')
         local oldfl=$(echo "$oldval" | jq -r '.[1]')
         [ "$se" == "$oldse" ] || curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleSequentialDownload?hashes=$QBhash"
         [ "$fl" == "$oldfl" ] || curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/toggleFirstLastPiecePrio?hashes=$QBhash"
     fi
fi
}

# qbtorblock: Scaled piece states string
# Usage: qbtorblock [-n [NUMBER_OF_BLOCKS]] [(-o FILE_INDEX | -i FILE_INDEX1 [FILE_INDEX2])]
# qbtorblock: Print a fixed number of symbols showing the state of pieces blocks of the selected torrent.
# qbtorblock: Without the "-n" options the number of blocks equals to $COLUMNS (of the current terminal).
# qbtorblock: If the option "-n" is present then the default number equals to the number of pieces of the torrent (so block=piece). 
# qbtorblock: The meaning of symbols:
# qbtorblock: "#" - completely downloaded block
# qbtorblock: "+" - partially downloaded block
# qbtorblock: "v" - downloading block
# qbtorblock: "-" - not downloaded (empty) block
# qbtorblock: The option "-o" specifies the index of a file, whose only pieces will be shown.
# qbtorblock: The option "-i" specifies the qbtorcontent interval of file indices whose pieces will be shown among other pieces. The pieces of files outside the interval will be marked by the dot (".")

alias qbtorblock="__META_qbcall qbtorblock"
function __META_qbtorblock ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
local aone="$COLUMNS"
if [ "$1" == "-n" ]
    then
     if [ "x${2:0:1}" == "x-" ]
        then
         aone=""
        else
         aone="$2"
         shift
     fi
     shift
fi
if [ "$1" == "-o" ]
    then
     local pi=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
     jq --arg i "$2" 'sort_by(.name)|.[($i|tonumber)].piece_range')
     if [ -z "$aone" ]
        then
         curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" '.[$pi|.[0]:($pi|.[1])+1]|[.[]|if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
        else
         curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
         jq -r --argjson pi "$pi" --arg aone "$aone" '.[$pi|.[0]:($pi|.[1])+1]|
         length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
         [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
         reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
         if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
     fi
    else
     if [ "$1" == "-i" ]
        then
         local arg3="$3"
         if [ -z $arg3 ]
            then
             arg3="$2"
         fi
         pi=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash"|
         jq -c --arg i "$2" --arg j "$arg3" 'sort_by(.name) as $inp|reduce range($i|tonumber;($j|tonumber)+1) as $n ([];.+[($inp|.[$n]).piece_range|range(.[0];.[1]+1)]|unique)')
         if [ -z "$aone" ]
            then
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" '. as $inp|length as $len| [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash"|
             jq -r --argjson pi "$pi" --arg aone "$aone" '. as $inp|length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|
             [range($len)| . as $i|if ($pi|index($i))==null then 3 else ($inp|.[$i]) end]|
             [.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
        fi
        else
         if [ -z "$aone" ]
            then
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r '[.[]|
             if .==0 then "-" else if .==1 then "v" else if .==2 then "#" else "." end end end]|add'
            else
             curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
             jq -r --arg aone "$aone" 'length as $len|($aone|tonumber) as $size|(-(-$size/$len|floor)) as $mult|[.[] as $n|(range($mult)|$n)]|
             [to_entries |[.[]|{"a":(.key*$size/($len*$mult)|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
             reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if (.==3 and $n==0) or (.==0 and $n==2) then 1 else . end end end)|
             if .==0 then "-" else if .==1 then "+" else if .==2 then "v" else if .==3 then "#" else "." end end end end]|add'
         fi
     fi
fi
     #jq --argjson pi "$pi" '. as $inp|[range($pi|.[0];($pi|.[1])+1)]|.[]| . as $ind | $inp|.[$ind]'
     #|.[]|. as $ind|($inp|.[$ind])]'

     #jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | .['"$1"'].key'
     #curl "${QBarg[@]}" -s  --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq '.['"$index"']
#fi
#curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/pieceStates?hash=$QBhash" |
#jq -r --arg aone "$1" ""'[length as $len|($aone|tonumber) as $size|to_entries |[.[]|{ "a":(.key*$size/$len|trunc),"b":.value}]|group_by(.a)|.[]|[.[].b]|
#reduce .[] as $n (4;if .==4 then if $n==0 then 0 else $n+1 end else if $n==1 then 2 else if .==3 and $n==0 then 1 else if .==0 and $n==2 then 1 else . end end end end)|tostring]|add'
}


# qbtorgeneral: Get the specified general properties of the selected torrent, or print all of them
# Usage: qbtorgeneral [(-r GEN_PROPERTY | GEN_PROPERTY_1 [GEN_PROPERTY_2 ...])]

alias qbtorgeneral="__META_qbcall qbtorgeneral"
function __META_qbtorgeneral ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ "$1" == "-r" ]
    then
     if [ -z "$2" ] || [ $# -gt 2 ]
        then
         >&2 qbhelp -u qbtorgeneral
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq -r ".$2"
     return 0
fi
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq
    else
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/properties?hash=$QBhash" | jq "$jj"
fi
return 0
}




# qbtortrack: Trackers info of the selected torrent
# Usage: qbtortrack

alias qbtortrack="__META_qbcall qbtortrack"
function __META_qbtortrack ()
{
if [ -z "$QBhash" ]
then
>&2 echo 'No torrent is selected'
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/trackers?hash=$QBhash" |
jq '.[]|.url+" ("+
(.status|if .==0 then "Disabled" else if .==1 then "Not contacted" else if .==2 then "Working" else if .==3 then "Updating" else "Not working" end end end end)+
"), p:"+(.num_peers|tostring)+" s:"+(.num_seeds|tostring)+" l:"+(.num_leeches|tostring)'
fi
}

# qbtortrackedit: Edit trackers of the selected torrent
# Usage: qbtortrackedit (-d URL | URL_1 [URL_2])
# qbtortrackedit: Options:
# qbtortrackedit: -d URL - Delete the tracker URL
# qbtortrackedit:  URL_1 [URL_2] - Add the tracker URL_1, or replace URL_2 by URL_1

alias qbtortrackedit="__META_qbcall qbtortrackedit"
function __META_qbtortrackedit ()
{
local resp
local url1=$(echo "$1"|jq -rR '@uri')
local url2=$(echo "$2"|jq -rR '@uri')
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtortrackedit
     return 127
fi
if [ "$1" == "-d" ]
    then
     if [ -z "$2" ]
      then
       >&2 qbhelp -u qbtortrackedit
       return 127
      else
       resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/removeTrackers?hash=$QBhash&urls=$url2" 2>/dev/null)
     fi
    else
     if [ -z "$2" ]
        then
         resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/addTrackers?hash=$QBhash&urls=$url1" 2>/dev/null)
        else
         resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/editTracker?hash=$QBhash&origUrl=$url2&newUrl=$url1" 2>/dev/null)
     fi
fi
if [ "$resp" != 200 ]
    then
     >&2 echo 'An error is occured'
     return 1
fi
return 0
}





# qbtorpeer: List of connected peers of the selected torrent with a short info
# Usage: qbtorpeer

alias qbtorpeer="__META_qbcall qbtorpeer"
function __META_qbtorpeer ()
{
if [ "x$QBhash" == "x" ]
then
>&2 echo No torrent is selected
return 1
else
curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/sync/torrentPeers?hash=$QBhash"| jq '[.peers | .[]] | sort_by(.progress) |.[] | (.progress*100 | trunc | tostring)+"% "+.ip+" "+.country_code+" "+(.dl_speed /1024 |trunc|tostring)+"Kb/s "+.client+"("+.connection+")"'
fi
}

# qbtorpeeradd: Add a peer
# Usage: qbtorpeeradd PEER

alias qbtorpeeradd="__META_qbcall qbtorpeeradd"
function __META_qbtorpeeradd ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtorpeeradd
     return 127
fi
local resp=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/addPeers?hashes=$QBhash&peers=$1" 2>/dev/null)
if [ "$resp" != "200" ]
    then
     if [ "$resp" == 400 ]
        then
         >&2 echo 'The peer is not valid'
        else
         >&2 echo 'An error is occured'
     fi
     return 1
fi
return 0
}




# qbtorcontent: List the files of the selected torrent with a short info
# Usage: qbtorcontent [FILE_INDEX_1] [FILE_INDEX_2]
# qbtorcontent: Without arguments list all files of the selected torrent in the alphabetical order with a short info. 
# qbtorcontent: If FILE_INDEX1 is indicated then the list starts with this index and finishes at FILE_INDEX2. 
# qbtorcontent: If no FILE_INDEX2 or FILE_INDEX2<FILE_INDEX1 the list contains only one item.

alias qbtorcontent="__META_qbcall qbtorcontent"
function __META_qbtorcontent ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo "No torrent is selected"
     return 1
fi
local arg2
if [ -z "$1" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name) |  to_entries | .[] | (.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
    else
     if [ -z $2 ]
        then arg2="$1"
        else arg2="$2"
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq 'sort_by(.name)|to_entries|[.['"$1"']]+.['"$1"'+1:'"$arg2"'+1]|.[]|(.key|tostring)+". "+.value.name+", "+(.value.progress*100|trunc|tostring)+"% of "+
     (.value.size /1048576|trunc|tostring)+"Mb, prio:"+(.value.priority|tostring)'
fi
return 0
}

# qbtorfile: Get the info of the specified file of the selected torrent
# Usage: qbtorfile FILE_INDEX [(-r PROPERTY | PROPERTY_1 [PROPERTY_2 ...])]
# qbtorfile: FILE_INDEX corresponds to the output of qbtorcontent

alias qbtorfile="__META_qbcall qbtorfile"
function __META_qbtorfile ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo 'No torrent is selected'
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtorfile
     return 127
fi
if [ "$2" == "-r" ]
    then
     if [ -z "$3" ] || [ $# -gt 3 ]
        then
         >&2 qbhelp -u qbtorfile
         return 127
     fi
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -rc 'sort_by(.name)|.['"$1"']|.'"$3"
     return 0
fi
if [ -z "$2" ]
    then
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq 'sort_by(.name)|.['"$1"']'
    else
     local j="$1"
     shift
     local jj='{"'"$1"'":.'"$1"
     shift
     while [ ! -z "$1" ]
        do
         jj="$jj"',"'"$1"'":.'"$1"
         shift
     done
     jj="$jj"'}'
     curl "${QBarg[@]}" -s --cookie "$QBcookie"  "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq 'sort_by(.name)|.['"$j"']|'"$jj"
fi
return 0
}

# qbtorfileprioedit: Set priority of all files of the selected torrent, or set the priority for the files in the qbcontent() interval
# Usage: qbtorfileprioedit NEW_PRIORITY [FILE_INDEX_1] [FILE_INDEX_2]
# qbtorfileprioedit: FILE_INDEX corresponds to the output of qbtorcontent

alias qbtorfileprioedit="__META_qbcall qbtorfileprioedit"
function __META_qbtorfileprioedit ()
{
if [ -z "$QBhash" ]
    then
     >&2 echo No torrent is selected
     return 1
fi
if [ -z "$1" ]
    then
     >&2 qbhelp -u qbtorfileprioedit
     return 127
fi
local index=""
local arg3
if [ -z "$2" ]
    then
     index=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" | jq -r '["0"]+[range(1;length)|tostring|"|"+.]|add' 2>/dev/null)
    else
     if [ -z $3 ]
        then arg3="$2"
        else arg3="$3"
     fi
     index=$(curl "${QBarg[@]}" -s --cookie "$QBcookie" "${QBurl}/api/v2/torrents/files?hash=$QBhash" |
     jq -r '[ .[] | .name ] | to_entries | sort_by(.value) | [(.['"$2"'].key|tostring)]+ [.['"$2"'+1:'"$arg3"'+1] | "|"+(.[].key|tostring)]|add' 2>/dev/null)
fi
if [ -z "$index" ]
    then
     >&2 echo "An error is occured"
     return 1
fi
local exitcode=$(curl "${QBarg[@]}" -s -o /dev/null -w "%{http_code}" --cookie "$QBcookie" "${QBurl}/api/v2/torrents/filePrio?hash=$QBhash&id=$index&priority=$1" 2>/dev/null)
if [ "$exitcode" == "200" ]
    then return 0
    else
     #TODO: add the exitcodes 400, 404,409
     >&2 echo "An error is occured"
     return 1
fi
}
shopt -s expand_aliases
HISTFILE="$HOME/.qbclient_history"
HISTCONTROL="ignoreboth:erasedups"
PROMPT_COMMAND='history -n; history -w; history -c; history -r; PS1=\$QBurl"/"\${QBhash:0:5}"> "'
#QBarg=("--cookie" "$QBcookie")
QBarg=()
[ -z "$QBarg1" ] || QBarg+=("$QBarg1")
[ -z "$QBarg2" ] || QBarg+=("$QBarg2")
unset QBarg1
unset QBarg2
__META_qblogin
exitcode=$?
[ "$exitcode" == "0" ] || builtin exit "$exitcode"
unset exitcode
QBchtime=$(date +%s)
